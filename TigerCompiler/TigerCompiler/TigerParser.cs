//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g 2012-12-07 13:56:58

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class TigerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ALIAS_DECL", "AND", "ARRAY_CREATION", "ARRAY_TYPE_DECL", "ASCII_ESC", "ASSIGN", "AT", "BREAK", "COMMENT", "DIV", "DOT", "EQUAL", "ESC_SEQ", "EXPRESSION_LIST", "EXPRESSION_SEQ", "FOR", "FUNCTION_CALL", "FUNCTION_DECL", "GT", "GT_EQUAL", "ID", "IF_THEN", "IF_THEN_ELSE", "INT", "LET", "LT", "LT_EQUAL", "LVALUE", "MINUS", "MUL", "NIL", "NON_EQUAL", "OR", "PLUS", "PRINTABLE_CHARACTER", "PROGRAM", "RECORD_CREATION", "RECORD_DECL", "STRING", "TYPE_DECL", "TYPE_ID", "UMINUS", "VAR_DECL", "WHILE", "WS", "'('", "')'", "','", "':'", "';'", "'['", "']'", "'array'", "'do'", "'else'", "'end'", "'function'", "'if'", "'in'", "'of'", "'then'", "'to'", "'type'", "'var'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int ALIAS_DECL=4;
	public const int AND=5;
	public const int ARRAY_CREATION=6;
	public const int ARRAY_TYPE_DECL=7;
	public const int ASCII_ESC=8;
	public const int ASSIGN=9;
	public const int AT=10;
	public const int BREAK=11;
	public const int COMMENT=12;
	public const int DIV=13;
	public const int DOT=14;
	public const int EQUAL=15;
	public const int ESC_SEQ=16;
	public const int EXPRESSION_LIST=17;
	public const int EXPRESSION_SEQ=18;
	public const int FOR=19;
	public const int FUNCTION_CALL=20;
	public const int FUNCTION_DECL=21;
	public const int GT=22;
	public const int GT_EQUAL=23;
	public const int ID=24;
	public const int IF_THEN=25;
	public const int IF_THEN_ELSE=26;
	public const int INT=27;
	public const int LET=28;
	public const int LT=29;
	public const int LT_EQUAL=30;
	public const int LVALUE=31;
	public const int MINUS=32;
	public const int MUL=33;
	public const int NIL=34;
	public const int NON_EQUAL=35;
	public const int OR=36;
	public const int PLUS=37;
	public const int PRINTABLE_CHARACTER=38;
	public const int PROGRAM=39;
	public const int RECORD_CREATION=40;
	public const int RECORD_DECL=41;
	public const int STRING=42;
	public const int TYPE_DECL=43;
	public const int TYPE_ID=44;
	public const int UMINUS=45;
	public const int VAR_DECL=46;
	public const int WHILE=47;
	public const int WS=48;

	public TigerParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TigerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return TigerParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:102:1: program : expr EOF -> ^( PROGRAM expr ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(102, 37);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:102:9: ( expr EOF -> ^( PROGRAM expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:102:11: expr EOF
			{
			DebugLocation(102, 11);
			PushFollow(Follow._expr_in_program628);
			expr1=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr1.Tree);
			DebugLocation(102, 16);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_program630); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 102:20: -> ^( PROGRAM expr )
			{
				DebugLocation(102, 23);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:102:23: ^( PROGRAM expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(102, 25);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(102, 33);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(102, 37);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:104:1: expr : or_expr ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 2);
		TraceIn("expr", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> or_expr3 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(104, 14);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:104:6: ( or_expr )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:104:8: or_expr
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(104, 8);
			PushFollow(Follow._or_expr_in_expr646);
			or_expr3=or_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, or_expr3.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 2);
			LeaveRule("expr", 2);
			LeaveRule_expr();
		}
		DebugLocation(104, 14);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_or_expr();
	partial void LeaveRule_or_expr();

	// $ANTLR start "or_expr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:1: or_expr : and_exp ( OR ^ and_exp )* ;
	[GrammarRule("or_expr")]
	private AstParserRuleReturnScope<object, IToken> or_expr()
	{
		EnterRule_or_expr();
		EnterRule("or_expr", 3);
		TraceIn("or_expr", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR5 = default(IToken);
		AstParserRuleReturnScope<object, IToken> and_exp4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> and_exp6 = default(AstParserRuleReturnScope<object, IToken>);

		object OR5_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "or_expr");
		DebugLocation(106, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:9: ( and_exp ( OR ^ and_exp )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:11: and_exp ( OR ^ and_exp )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(106, 11);
			PushFollow(Follow._and_exp_in_or_expr654);
			and_exp4=and_exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, and_exp4.Tree);
			DebugLocation(106, 19);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:19: ( OR ^ and_exp )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==OR))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:20: OR ^ and_exp
					{
					DebugLocation(106, 22);
					OR5=(IToken)Match(input,OR,Follow._OR_in_or_expr657); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR5_tree = (object)adaptor.Create(OR5);
					root_0 = (object)adaptor.BecomeRoot(OR5_tree, root_0);
					}
					DebugLocation(106, 24);
					PushFollow(Follow._and_exp_in_or_expr660);
					and_exp6=and_exp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, and_exp6.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("or_expr", 3);
			LeaveRule("or_expr", 3);
			LeaveRule_or_expr();
		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "or_expr"); }
		return retval;

	}
	// $ANTLR end "or_expr"

	partial void EnterRule_and_exp();
	partial void LeaveRule_and_exp();

	// $ANTLR start "and_exp"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:109:1: and_exp : comp_expr ( AND ^ comp_expr )* ;
	[GrammarRule("and_exp")]
	private AstParserRuleReturnScope<object, IToken> and_exp()
	{
		EnterRule_and_exp();
		EnterRule("and_exp", 4);
		TraceIn("and_exp", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND8 = default(IToken);
		AstParserRuleReturnScope<object, IToken> comp_expr7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> comp_expr9 = default(AstParserRuleReturnScope<object, IToken>);

		object AND8_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "and_exp");
		DebugLocation(109, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:109:9: ( comp_expr ( AND ^ comp_expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:109:11: comp_expr ( AND ^ comp_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(109, 11);
			PushFollow(Follow._comp_expr_in_and_exp672);
			comp_expr7=comp_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, comp_expr7.Tree);
			DebugLocation(109, 21);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:109:21: ( AND ^ comp_expr )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==AND))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:109:22: AND ^ comp_expr
					{
					DebugLocation(109, 25);
					AND8=(IToken)Match(input,AND,Follow._AND_in_and_exp675); if (state.failed) return retval;
					if (state.backtracking == 0) {
					AND8_tree = (object)adaptor.Create(AND8);
					root_0 = (object)adaptor.BecomeRoot(AND8_tree, root_0);
					}
					DebugLocation(109, 27);
					PushFollow(Follow._comp_expr_in_and_exp678);
					comp_expr9=comp_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, comp_expr9.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("and_exp", 4);
			LeaveRule("and_exp", 4);
			LeaveRule_and_exp();
		}
		DebugLocation(110, 1);
		} finally { DebugExitRule(GrammarFileName, "and_exp"); }
		return retval;

	}
	// $ANTLR end "and_exp"

	partial void EnterRule_comp_expr();
	partial void LeaveRule_comp_expr();

	// $ANTLR start "comp_expr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:112:1: comp_expr : arith_expr ( ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr )* ;
	[GrammarRule("comp_expr")]
	private AstParserRuleReturnScope<object, IToken> comp_expr()
	{
		EnterRule_comp_expr();
		EnterRule("comp_expr", 5);
		TraceIn("comp_expr", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQUAL11 = default(IToken);
		IToken NON_EQUAL12 = default(IToken);
		IToken LT13 = default(IToken);
		IToken GT14 = default(IToken);
		IToken LT_EQUAL15 = default(IToken);
		IToken GT_EQUAL16 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arith_expr10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arith_expr17 = default(AstParserRuleReturnScope<object, IToken>);

		object EQUAL11_tree = default(object);
		object NON_EQUAL12_tree = default(object);
		object LT13_tree = default(object);
		object GT14_tree = default(object);
		object LT_EQUAL15_tree = default(object);
		object GT_EQUAL16_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "comp_expr");
		DebugLocation(112, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:2: ( arith_expr ( ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:4: arith_expr ( ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(113, 4);
			PushFollow(Follow._arith_expr_in_comp_expr691);
			arith_expr10=arith_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, arith_expr10.Tree);
			DebugLocation(113, 14);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:14: ( ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				switch (input.LA(1))
				{
				case EQUAL:
					{
					alt4 = 1;
					}
					break;
				case NON_EQUAL:
					{
					alt4 = 1;
					}
					break;
				case LT:
					{
					alt4 = 1;
					}
					break;
				case GT:
					{
					alt4 = 1;
					}
					break;
				case LT_EQUAL:
					{
					alt4 = 1;
					}
					break;
				case GT_EQUAL:
					{
					alt4 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:15: ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr
					{
					DebugLocation(113, 15);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:15: ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^)
					int alt3=6;
					try { DebugEnterSubRule(3);
					try { DebugEnterDecision(3, false);
					switch (input.LA(1))
					{
					case EQUAL:
						{
						alt3 = 1;
						}
						break;
					case NON_EQUAL:
						{
						alt3 = 2;
						}
						break;
					case LT:
						{
						alt3 = 3;
						}
						break;
					case GT:
						{
						alt3 = 4;
						}
						break;
					case LT_EQUAL:
						{
						alt3 = 5;
						}
						break;
					case GT_EQUAL:
						{
						alt3 = 6;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:16: EQUAL ^
						{
						DebugLocation(113, 21);
						EQUAL11=(IToken)Match(input,EQUAL,Follow._EQUAL_in_comp_expr694); if (state.failed) return retval;
						if (state.backtracking == 0) {
						EQUAL11_tree = (object)adaptor.Create(EQUAL11);
						root_0 = (object)adaptor.BecomeRoot(EQUAL11_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:25: NON_EQUAL ^
						{
						DebugLocation(113, 34);
						NON_EQUAL12=(IToken)Match(input,NON_EQUAL,Follow._NON_EQUAL_in_comp_expr699); if (state.failed) return retval;
						if (state.backtracking == 0) {
						NON_EQUAL12_tree = (object)adaptor.Create(NON_EQUAL12);
						root_0 = (object)adaptor.BecomeRoot(NON_EQUAL12_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:38: LT ^
						{
						DebugLocation(113, 40);
						LT13=(IToken)Match(input,LT,Follow._LT_in_comp_expr704); if (state.failed) return retval;
						if (state.backtracking == 0) {
						LT13_tree = (object)adaptor.Create(LT13);
						root_0 = (object)adaptor.BecomeRoot(LT13_tree, root_0);
						}

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:44: GT ^
						{
						DebugLocation(113, 46);
						GT14=(IToken)Match(input,GT,Follow._GT_in_comp_expr709); if (state.failed) return retval;
						if (state.backtracking == 0) {
						GT14_tree = (object)adaptor.Create(GT14);
						root_0 = (object)adaptor.BecomeRoot(GT14_tree, root_0);
						}

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:50: LT_EQUAL ^
						{
						DebugLocation(113, 58);
						LT_EQUAL15=(IToken)Match(input,LT_EQUAL,Follow._LT_EQUAL_in_comp_expr714); if (state.failed) return retval;
						if (state.backtracking == 0) {
						LT_EQUAL15_tree = (object)adaptor.Create(LT_EQUAL15);
						root_0 = (object)adaptor.BecomeRoot(LT_EQUAL15_tree, root_0);
						}

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:62: GT_EQUAL ^
						{
						DebugLocation(113, 70);
						GT_EQUAL16=(IToken)Match(input,GT_EQUAL,Follow._GT_EQUAL_in_comp_expr719); if (state.failed) return retval;
						if (state.backtracking == 0) {
						GT_EQUAL16_tree = (object)adaptor.Create(GT_EQUAL16);
						root_0 = (object)adaptor.BecomeRoot(GT_EQUAL16_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(3); }

					DebugLocation(113, 73);
					PushFollow(Follow._arith_expr_in_comp_expr723);
					arith_expr17=arith_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, arith_expr17.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("comp_expr", 5);
			LeaveRule("comp_expr", 5);
			LeaveRule_comp_expr();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "comp_expr"); }
		return retval;

	}
	// $ANTLR end "comp_expr"

	partial void EnterRule_arith_expr();
	partial void LeaveRule_arith_expr();

	// $ANTLR start "arith_expr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:116:1: arith_expr : term ( ( PLUS ^| MINUS ^) term )* ;
	[GrammarRule("arith_expr")]
	private AstParserRuleReturnScope<object, IToken> arith_expr()
	{
		EnterRule_arith_expr();
		EnterRule("arith_expr", 6);
		TraceIn("arith_expr", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS19 = default(IToken);
		IToken MINUS20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term21 = default(AstParserRuleReturnScope<object, IToken>);

		object PLUS19_tree = default(object);
		object MINUS20_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "arith_expr");
		DebugLocation(116, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:2: ( term ( ( PLUS ^| MINUS ^) term )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:4: term ( ( PLUS ^| MINUS ^) term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(117, 4);
			PushFollow(Follow._term_in_arith_expr736);
			term18=term();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, term18.Tree);
			DebugLocation(117, 8);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:8: ( ( PLUS ^| MINUS ^) term )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==PLUS))
				{
					alt6 = 1;
				}
				else if ((LA6_0==MINUS))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:9: ( PLUS ^| MINUS ^) term
					{
					DebugLocation(117, 9);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:9: ( PLUS ^| MINUS ^)
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==PLUS))
					{
						alt5 = 1;
					}
					else if ((LA5_0==MINUS))
					{
						alt5 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:10: PLUS ^
						{
						DebugLocation(117, 14);
						PLUS19=(IToken)Match(input,PLUS,Follow._PLUS_in_arith_expr739); if (state.failed) return retval;
						if (state.backtracking == 0) {
						PLUS19_tree = (object)adaptor.Create(PLUS19);
						root_0 = (object)adaptor.BecomeRoot(PLUS19_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:16: MINUS ^
						{
						DebugLocation(117, 21);
						MINUS20=(IToken)Match(input,MINUS,Follow._MINUS_in_arith_expr742); if (state.failed) return retval;
						if (state.backtracking == 0) {
						MINUS20_tree = (object)adaptor.Create(MINUS20);
						root_0 = (object)adaptor.BecomeRoot(MINUS20_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(5); }

					DebugLocation(117, 24);
					PushFollow(Follow._term_in_arith_expr746);
					term21=term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, term21.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arith_expr", 6);
			LeaveRule("arith_expr", 6);
			LeaveRule_arith_expr();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "arith_expr"); }
		return retval;

	}
	// $ANTLR end "arith_expr"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:1: term : texpr ( ( MUL ^| DIV ^) texpr )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 7);
		TraceIn("term", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MUL23 = default(IToken);
		IToken DIV24 = default(IToken);
		AstParserRuleReturnScope<object, IToken> texpr22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> texpr25 = default(AstParserRuleReturnScope<object, IToken>);

		object MUL23_tree = default(object);
		object DIV24_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(120, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:6: ( texpr ( ( MUL ^| DIV ^) texpr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:8: texpr ( ( MUL ^| DIV ^) texpr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(120, 8);
			PushFollow(Follow._texpr_in_term758);
			texpr22=texpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, texpr22.Tree);
			DebugLocation(120, 13);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:13: ( ( MUL ^| DIV ^) texpr )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==MUL))
				{
					alt8 = 1;
				}
				else if ((LA8_0==DIV))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:14: ( MUL ^| DIV ^) texpr
					{
					DebugLocation(120, 14);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:14: ( MUL ^| DIV ^)
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==MUL))
					{
						alt7 = 1;
					}
					else if ((LA7_0==DIV))
					{
						alt7 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:15: MUL ^
						{
						DebugLocation(120, 18);
						MUL23=(IToken)Match(input,MUL,Follow._MUL_in_term761); if (state.failed) return retval;
						if (state.backtracking == 0) {
						MUL23_tree = (object)adaptor.Create(MUL23);
						root_0 = (object)adaptor.BecomeRoot(MUL23_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:20: DIV ^
						{
						DebugLocation(120, 23);
						DIV24=(IToken)Match(input,DIV,Follow._DIV_in_term764); if (state.failed) return retval;
						if (state.backtracking == 0) {
						DIV24_tree = (object)adaptor.Create(DIV24);
						root_0 = (object)adaptor.BecomeRoot(DIV24_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(120, 26);
					PushFollow(Follow._texpr_in_term768);
					texpr25=texpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, texpr25.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 7);
			LeaveRule("term", 7);
			LeaveRule_term();
		}
		DebugLocation(121, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_texpr();
	partial void LeaveRule_texpr();

	// $ANTLR start "texpr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:123:1: texpr : ( STRING | INT | NIL | ( ID '[' expr ']' 'of' )=> type_id '[' e1= expr ']' 'of' e2= expr -> ^( ARRAY_CREATION type_id $e1 $e2) | ( ID '(' )=> ( ID '(' ( expr_list )? ')' ) -> ^( FUNCTION_CALL ID ^( EXPRESSION_LIST ( expr_list )? ) ) | ( ID '{' )=> ( ID '{' ( field_list )? '}' ) -> ^( RECORD_CREATION ID ( field_list )? ) | ( lvalue ASSIGN )=> ( lvalue ASSIGN expr ) -> ^( ASSIGN lvalue expr ) | lvalue | '(' ( expr_seq )? ')' -> ^( EXPRESSION_SEQ ( expr_seq )? ) | ( 'if' expr 'then' expr 'else' )=> ( 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr ) -> ^( IF_THEN_ELSE $ifx $thenx $elsex) | 'if' ifx= expr 'then' elsex= expr -> ^( IF_THEN $ifx $elsex) | WHILE condition= expr 'do' something= expr -> ^( WHILE $condition $something) | FOR var= ID ASSIGN init= expr 'to' limit= expr 'do' something= expr -> ^( FOR $var $init $limit $something) | BREAK | LET declaration_list 'in' ( expr_seq )? 'end' -> ^( LET declaration_list ( expr_seq )? ) | MINUS texpr -> ^( UMINUS texpr ) );
	[GrammarRule("texpr")]
	private AstParserRuleReturnScope<object, IToken> texpr()
	{
		EnterRule_texpr();
		EnterRule("texpr", 8);
		TraceIn("texpr", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken var = default(IToken);
		IToken STRING26 = default(IToken);
		IToken INT27 = default(IToken);
		IToken NIL28 = default(IToken);
		IToken char_literal30 = default(IToken);
		IToken char_literal31 = default(IToken);
		IToken string_literal32 = default(IToken);
		IToken ID33 = default(IToken);
		IToken char_literal34 = default(IToken);
		IToken char_literal36 = default(IToken);
		IToken ID37 = default(IToken);
		IToken char_literal38 = default(IToken);
		IToken char_literal40 = default(IToken);
		IToken ASSIGN42 = default(IToken);
		IToken char_literal45 = default(IToken);
		IToken char_literal47 = default(IToken);
		IToken string_literal48 = default(IToken);
		IToken string_literal49 = default(IToken);
		IToken string_literal50 = default(IToken);
		IToken string_literal51 = default(IToken);
		IToken string_literal52 = default(IToken);
		IToken WHILE53 = default(IToken);
		IToken string_literal54 = default(IToken);
		IToken FOR55 = default(IToken);
		IToken ASSIGN56 = default(IToken);
		IToken string_literal57 = default(IToken);
		IToken string_literal58 = default(IToken);
		IToken BREAK59 = default(IToken);
		IToken LET60 = default(IToken);
		IToken string_literal62 = default(IToken);
		IToken string_literal64 = default(IToken);
		IToken MINUS65 = default(IToken);
		AstParserRuleReturnScope<object, IToken> e1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> e2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ifx = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> thenx = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> elsex = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> condition = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> something = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> init = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> limit = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id29 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_list35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> field_list39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue44 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> declaration_list61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq63 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> texpr66 = default(AstParserRuleReturnScope<object, IToken>);

		object var_tree = default(object);
		object STRING26_tree = default(object);
		object INT27_tree = default(object);
		object NIL28_tree = default(object);
		object char_literal30_tree = default(object);
		object char_literal31_tree = default(object);
		object string_literal32_tree = default(object);
		object ID33_tree = default(object);
		object char_literal34_tree = default(object);
		object char_literal36_tree = default(object);
		object ID37_tree = default(object);
		object char_literal38_tree = default(object);
		object char_literal40_tree = default(object);
		object ASSIGN42_tree = default(object);
		object char_literal45_tree = default(object);
		object char_literal47_tree = default(object);
		object string_literal48_tree = default(object);
		object string_literal49_tree = default(object);
		object string_literal50_tree = default(object);
		object string_literal51_tree = default(object);
		object string_literal52_tree = default(object);
		object WHILE53_tree = default(object);
		object string_literal54_tree = default(object);
		object FOR55_tree = default(object);
		object ASSIGN56_tree = default(object);
		object string_literal57_tree = default(object);
		object string_literal58_tree = default(object);
		object BREAK59_tree = default(object);
		object LET60_tree = default(object);
		object string_literal62_tree = default(object);
		object string_literal64_tree = default(object);
		object MINUS65_tree = default(object);
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_LET=new RewriteRuleITokenStream(adaptor,"token LET");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		RewriteRuleSubtreeStream stream_declaration_list=new RewriteRuleSubtreeStream(adaptor,"rule declaration_list");
		RewriteRuleSubtreeStream stream_lvalue=new RewriteRuleSubtreeStream(adaptor,"rule lvalue");
		RewriteRuleSubtreeStream stream_field_list=new RewriteRuleSubtreeStream(adaptor,"rule field_list");
		RewriteRuleSubtreeStream stream_texpr=new RewriteRuleSubtreeStream(adaptor,"rule texpr");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_expr_seq=new RewriteRuleSubtreeStream(adaptor,"rule expr_seq");
		RewriteRuleSubtreeStream stream_expr_list=new RewriteRuleSubtreeStream(adaptor,"rule expr_list");
		try { DebugEnterRule(GrammarFileName, "texpr");
		DebugLocation(123, 2);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:123:6: ( STRING | INT | NIL | ( ID '[' expr ']' 'of' )=> type_id '[' e1= expr ']' 'of' e2= expr -> ^( ARRAY_CREATION type_id $e1 $e2) | ( ID '(' )=> ( ID '(' ( expr_list )? ')' ) -> ^( FUNCTION_CALL ID ^( EXPRESSION_LIST ( expr_list )? ) ) | ( ID '{' )=> ( ID '{' ( field_list )? '}' ) -> ^( RECORD_CREATION ID ( field_list )? ) | ( lvalue ASSIGN )=> ( lvalue ASSIGN expr ) -> ^( ASSIGN lvalue expr ) | lvalue | '(' ( expr_seq )? ')' -> ^( EXPRESSION_SEQ ( expr_seq )? ) | ( 'if' expr 'then' expr 'else' )=> ( 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr ) -> ^( IF_THEN_ELSE $ifx $thenx $elsex) | 'if' ifx= expr 'then' elsex= expr -> ^( IF_THEN $ifx $elsex) | WHILE condition= expr 'do' something= expr -> ^( WHILE $condition $something) | FOR var= ID ASSIGN init= expr 'to' limit= expr 'do' something= expr -> ^( FOR $var $init $limit $something) | BREAK | LET declaration_list 'in' ( expr_seq )? 'end' -> ^( LET declaration_list ( expr_seq )? ) | MINUS texpr -> ^( UMINUS texpr ) )
			int alt13=16;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case STRING:
				{
				alt13 = 1;
				}
				break;
			case INT:
				{
				alt13 = 2;
				}
				break;
			case NIL:
				{
				alt13 = 3;
				}
				break;
			case ID:
				{
				int LA13_4 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Tiger_fragment)))
				{
					alt13 = 4;
				}
				else if ((EvaluatePredicate(synpred2_Tiger_fragment)))
				{
					alt13 = 5;
				}
				else if ((EvaluatePredicate(synpred3_Tiger_fragment)))
				{
					alt13 = 6;
				}
				else if ((EvaluatePredicate(synpred4_Tiger_fragment)))
				{
					alt13 = 7;
				}
				else if ((true))
				{
					alt13 = 8;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 4, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 49:
				{
				alt13 = 9;
				}
				break;
			case 61:
				{
				int LA13_6 = input.LA(2);

				if ((EvaluatePredicate(synpred5_Tiger_fragment)))
				{
					alt13 = 10;
				}
				else if ((true))
				{
					alt13 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case WHILE:
				{
				alt13 = 12;
				}
				break;
			case FOR:
				{
				alt13 = 13;
				}
				break;
			case BREAK:
				{
				alt13 = 14;
				}
				break;
			case LET:
				{
				alt13 = 15;
				}
				break;
			case MINUS:
				{
				alt13 = 16;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:123:12: STRING
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(123, 12);
				STRING26=(IToken)Match(input,STRING,Follow._STRING_in_texpr783); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STRING26_tree = (object)adaptor.Create(STRING26);
				adaptor.AddChild(root_0, STRING26_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:5: INT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(124, 5);
				INT27=(IToken)Match(input,INT,Follow._INT_in_texpr789); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INT27_tree = (object)adaptor.Create(INT27);
				adaptor.AddChild(root_0, INT27_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:5: NIL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(125, 5);
				NIL28=(IToken)Match(input,NIL,Follow._NIL_in_texpr795); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NIL28_tree = (object)adaptor.Create(NIL28);
				adaptor.AddChild(root_0, NIL28_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:5: ( ID '[' expr ']' 'of' )=> type_id '[' e1= expr ']' 'of' e2= expr
				{
				DebugLocation(126, 31);
				PushFollow(Follow._type_id_in_texpr815);
				type_id29=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id29.Tree);
				DebugLocation(126, 39);
				char_literal30=(IToken)Match(input,54,Follow._54_in_texpr817); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_54.Add(char_literal30);

				DebugLocation(126, 45);
				PushFollow(Follow._expr_in_texpr821);
				e1=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(e1.Tree);
				DebugLocation(126, 51);
				char_literal31=(IToken)Match(input,55,Follow._55_in_texpr823); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_55.Add(char_literal31);

				DebugLocation(126, 55);
				string_literal32=(IToken)Match(input,63,Follow._63_in_texpr825); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal32);

				DebugLocation(126, 62);
				PushFollow(Follow._expr_in_texpr829);
				e2=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(e2.Tree);


				{
				// AST REWRITE
				// elements: e1, type_id, e2
				// token labels: 
				// rule labels: retval, e1, e2
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.Tree:null);
				RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 126:68: -> ^( ARRAY_CREATION type_id $e1 $e2)
				{
					DebugLocation(126, 71);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:71: ^( ARRAY_CREATION type_id $e1 $e2)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(126, 73);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_CREATION, "ARRAY_CREATION"), root_1);

					DebugLocation(126, 88);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(126, 97);
					adaptor.AddChild(root_1, stream_e1.NextTree());
					DebugLocation(126, 101);
					adaptor.AddChild(root_1, stream_e2.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:5: ( ID '(' )=> ( ID '(' ( expr_list )? ')' )
				{
				DebugLocation(127, 15);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:15: ( ID '(' ( expr_list )? ')' )
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:16: ID '(' ( expr_list )? ')'
				{
				DebugLocation(127, 16);
				ID33=(IToken)Match(input,ID,Follow._ID_in_texpr857); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID33);

				DebugLocation(127, 19);
				char_literal34=(IToken)Match(input,49,Follow._49_in_texpr859); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(char_literal34);

				DebugLocation(127, 23);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:23: ( expr_list )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==BREAK||LA9_0==FOR||LA9_0==ID||(LA9_0>=INT && LA9_0<=LET)||LA9_0==MINUS||LA9_0==NIL||LA9_0==STRING||LA9_0==WHILE||LA9_0==49||LA9_0==61))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:23: expr_list
					{
					DebugLocation(127, 23);
					PushFollow(Follow._expr_list_in_texpr861);
					expr_list35=expr_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_list.Add(expr_list35.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(127, 34);
				char_literal36=(IToken)Match(input,50,Follow._50_in_texpr864); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_50.Add(char_literal36);


				}



				{
				// AST REWRITE
				// elements: ID, expr_list
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 127:39: -> ^( FUNCTION_CALL ID ^( EXPRESSION_LIST ( expr_list )? ) )
				{
					DebugLocation(127, 42);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:42: ^( FUNCTION_CALL ID ^( EXPRESSION_LIST ( expr_list )? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(127, 44);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_CALL, "FUNCTION_CALL"), root_1);

					DebugLocation(127, 58);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(127, 61);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:61: ^( EXPRESSION_LIST ( expr_list )? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(127, 63);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSION_LIST, "EXPRESSION_LIST"), root_2);

					DebugLocation(127, 79);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:79: ( expr_list )?
					if (stream_expr_list.HasNext)
					{
						DebugLocation(127, 79);
						adaptor.AddChild(root_2, stream_expr_list.NextTree());

					}
					stream_expr_list.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:5: ( ID '{' )=> ( ID '{' ( field_list )? '}' )
				{
				DebugLocation(128, 17);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:17: ( ID '{' ( field_list )? '}' )
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:18: ID '{' ( field_list )? '}'
				{
				DebugLocation(128, 18);
				ID37=(IToken)Match(input,ID,Follow._ID_in_texpr895); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID37);

				DebugLocation(128, 21);
				char_literal38=(IToken)Match(input,68,Follow._68_in_texpr897); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_68.Add(char_literal38);

				DebugLocation(128, 25);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:25: ( field_list )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==ID))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:25: field_list
					{
					DebugLocation(128, 25);
					PushFollow(Follow._field_list_in_texpr899);
					field_list39=field_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_field_list.Add(field_list39.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(128, 37);
				char_literal40=(IToken)Match(input,69,Follow._69_in_texpr902); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_69.Add(char_literal40);


				}



				{
				// AST REWRITE
				// elements: field_list, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 128:42: -> ^( RECORD_CREATION ID ( field_list )? )
				{
					DebugLocation(128, 45);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:45: ^( RECORD_CREATION ID ( field_list )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(128, 47);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_CREATION, "RECORD_CREATION"), root_1);

					DebugLocation(128, 63);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(128, 66);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:66: ( field_list )?
					if (stream_field_list.HasNext)
					{
						DebugLocation(128, 66);
						adaptor.AddChild(root_1, stream_field_list.NextTree());

					}
					stream_field_list.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:5: ( lvalue ASSIGN )=> ( lvalue ASSIGN expr )
				{
				DebugLocation(129, 24);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:24: ( lvalue ASSIGN expr )
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:25: lvalue ASSIGN expr
				{
				DebugLocation(129, 25);
				PushFollow(Follow._lvalue_in_texpr929);
				lvalue41=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_lvalue.Add(lvalue41.Tree);
				DebugLocation(129, 32);
				ASSIGN42=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_texpr931); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN42);

				DebugLocation(129, 39);
				PushFollow(Follow._expr_in_texpr933);
				expr43=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr43.Tree);

				}



				{
				// AST REWRITE
				// elements: ASSIGN, expr, lvalue
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 129:45: -> ^( ASSIGN lvalue expr )
				{
					DebugLocation(129, 48);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:48: ^( ASSIGN lvalue expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(129, 50);
					root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

					DebugLocation(129, 57);
					adaptor.AddChild(root_1, stream_lvalue.NextTree());
					DebugLocation(129, 64);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:130:5: lvalue
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(130, 5);
				PushFollow(Follow._lvalue_in_texpr950);
				lvalue44=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, lvalue44.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:131:5: '(' ( expr_seq )? ')'
				{
				DebugLocation(131, 5);
				char_literal45=(IToken)Match(input,49,Follow._49_in_texpr956); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(char_literal45);

				DebugLocation(131, 9);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:131:9: ( expr_seq )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==BREAK||LA11_0==FOR||LA11_0==ID||(LA11_0>=INT && LA11_0<=LET)||LA11_0==MINUS||LA11_0==NIL||LA11_0==STRING||LA11_0==WHILE||LA11_0==49||LA11_0==61))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:131:9: expr_seq
					{
					DebugLocation(131, 9);
					PushFollow(Follow._expr_seq_in_texpr958);
					expr_seq46=expr_seq();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_seq.Add(expr_seq46.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(131, 19);
				char_literal47=(IToken)Match(input,50,Follow._50_in_texpr961); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_50.Add(char_literal47);



				{
				// AST REWRITE
				// elements: expr_seq
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 131:23: -> ^( EXPRESSION_SEQ ( expr_seq )? )
				{
					DebugLocation(131, 26);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:131:26: ^( EXPRESSION_SEQ ( expr_seq )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(131, 28);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSION_SEQ, "EXPRESSION_SEQ"), root_1);

					DebugLocation(131, 43);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:131:43: ( expr_seq )?
					if (stream_expr_seq.HasNext)
					{
						DebugLocation(131, 43);
						adaptor.AddChild(root_1, stream_expr_seq.NextTree());

					}
					stream_expr_seq.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:132:5: ( 'if' expr 'then' expr 'else' )=> ( 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr )
				{
				DebugLocation(132, 39);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:132:39: ( 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr )
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:132:40: 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr
				{
				DebugLocation(132, 40);
				string_literal48=(IToken)Match(input,61,Follow._61_in_texpr991); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_61.Add(string_literal48);

				DebugLocation(132, 48);
				PushFollow(Follow._expr_in_texpr995);
				ifx=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(ifx.Tree);
				DebugLocation(132, 54);
				string_literal49=(IToken)Match(input,64,Follow._64_in_texpr997); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal49);

				DebugLocation(132, 66);
				PushFollow(Follow._expr_in_texpr1001);
				thenx=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(thenx.Tree);
				DebugLocation(132, 72);
				string_literal50=(IToken)Match(input,58,Follow._58_in_texpr1003); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_58.Add(string_literal50);

				DebugLocation(132, 84);
				PushFollow(Follow._expr_in_texpr1007);
				elsex=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(elsex.Tree);

				}



				{
				// AST REWRITE
				// elements: elsex, ifx, thenx
				// token labels: 
				// rule labels: ifx, retval, thenx, elsex
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ifx=new RewriteRuleSubtreeStream(adaptor,"rule ifx",ifx!=null?ifx.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_thenx=new RewriteRuleSubtreeStream(adaptor,"rule thenx",thenx!=null?thenx.Tree:null);
				RewriteRuleSubtreeStream stream_elsex=new RewriteRuleSubtreeStream(adaptor,"rule elsex",elsex!=null?elsex.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 132:91: -> ^( IF_THEN_ELSE $ifx $thenx $elsex)
				{
					DebugLocation(132, 94);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:132:94: ^( IF_THEN_ELSE $ifx $thenx $elsex)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(132, 96);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF_THEN_ELSE, "IF_THEN_ELSE"), root_1);

					DebugLocation(132, 110);
					adaptor.AddChild(root_1, stream_ifx.NextTree());
					DebugLocation(132, 115);
					adaptor.AddChild(root_1, stream_thenx.NextTree());
					DebugLocation(132, 122);
					adaptor.AddChild(root_1, stream_elsex.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:133:5: 'if' ifx= expr 'then' elsex= expr
				{
				DebugLocation(133, 5);
				string_literal51=(IToken)Match(input,61,Follow._61_in_texpr1029); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_61.Add(string_literal51);

				DebugLocation(133, 13);
				PushFollow(Follow._expr_in_texpr1033);
				ifx=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(ifx.Tree);
				DebugLocation(133, 19);
				string_literal52=(IToken)Match(input,64,Follow._64_in_texpr1035); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal52);

				DebugLocation(133, 31);
				PushFollow(Follow._expr_in_texpr1039);
				elsex=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(elsex.Tree);


				{
				// AST REWRITE
				// elements: elsex, ifx
				// token labels: 
				// rule labels: ifx, retval, elsex
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ifx=new RewriteRuleSubtreeStream(adaptor,"rule ifx",ifx!=null?ifx.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_elsex=new RewriteRuleSubtreeStream(adaptor,"rule elsex",elsex!=null?elsex.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 133:37: -> ^( IF_THEN $ifx $elsex)
				{
					DebugLocation(133, 40);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:133:40: ^( IF_THEN $ifx $elsex)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(133, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF_THEN, "IF_THEN"), root_1);

					DebugLocation(133, 51);
					adaptor.AddChild(root_1, stream_ifx.NextTree());
					DebugLocation(133, 56);
					adaptor.AddChild(root_1, stream_elsex.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:134:5: WHILE condition= expr 'do' something= expr
				{
				DebugLocation(134, 5);
				WHILE53=(IToken)Match(input,WHILE,Follow._WHILE_in_texpr1057); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WHILE.Add(WHILE53);

				DebugLocation(134, 20);
				PushFollow(Follow._expr_in_texpr1061);
				condition=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(condition.Tree);
				DebugLocation(134, 26);
				string_literal54=(IToken)Match(input,57,Follow._57_in_texpr1063); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(string_literal54);

				DebugLocation(134, 40);
				PushFollow(Follow._expr_in_texpr1067);
				something=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(something.Tree);


				{
				// AST REWRITE
				// elements: condition, WHILE, something
				// token labels: 
				// rule labels: retval, condition, something
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition",condition!=null?condition.Tree:null);
				RewriteRuleSubtreeStream stream_something=new RewriteRuleSubtreeStream(adaptor,"rule something",something!=null?something.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 134:46: -> ^( WHILE $condition $something)
				{
					DebugLocation(134, 49);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:134:49: ^( WHILE $condition $something)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(134, 51);
					root_1 = (object)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

					DebugLocation(134, 58);
					adaptor.AddChild(root_1, stream_condition.NextTree());
					DebugLocation(134, 69);
					adaptor.AddChild(root_1, stream_something.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:135:5: FOR var= ID ASSIGN init= expr 'to' limit= expr 'do' something= expr
				{
				DebugLocation(135, 5);
				FOR55=(IToken)Match(input,FOR,Follow._FOR_in_texpr1085); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FOR.Add(FOR55);

				DebugLocation(135, 12);
				var=(IToken)Match(input,ID,Follow._ID_in_texpr1089); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(var);

				DebugLocation(135, 16);
				ASSIGN56=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_texpr1091); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN56);

				DebugLocation(135, 27);
				PushFollow(Follow._expr_in_texpr1095);
				init=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(init.Tree);
				DebugLocation(135, 33);
				string_literal57=(IToken)Match(input,65,Follow._65_in_texpr1097); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_65.Add(string_literal57);

				DebugLocation(135, 43);
				PushFollow(Follow._expr_in_texpr1101);
				limit=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(limit.Tree);
				DebugLocation(135, 49);
				string_literal58=(IToken)Match(input,57,Follow._57_in_texpr1103); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(string_literal58);

				DebugLocation(135, 63);
				PushFollow(Follow._expr_in_texpr1107);
				something=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(something.Tree);


				{
				// AST REWRITE
				// elements: limit, something, var, FOR, init
				// token labels: var
				// rule labels: limit, retval, init, something
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_var=new RewriteRuleITokenStream(adaptor,"token var",var);
				RewriteRuleSubtreeStream stream_limit=new RewriteRuleSubtreeStream(adaptor,"rule limit",limit!=null?limit.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_init=new RewriteRuleSubtreeStream(adaptor,"rule init",init!=null?init.Tree:null);
				RewriteRuleSubtreeStream stream_something=new RewriteRuleSubtreeStream(adaptor,"rule something",something!=null?something.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 135:69: -> ^( FOR $var $init $limit $something)
				{
					DebugLocation(135, 72);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:135:72: ^( FOR $var $init $limit $something)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(135, 74);
					root_1 = (object)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

					DebugLocation(135, 79);
					adaptor.AddChild(root_1, stream_var.NextNode());
					DebugLocation(135, 84);
					adaptor.AddChild(root_1, stream_init.NextTree());
					DebugLocation(135, 90);
					adaptor.AddChild(root_1, stream_limit.NextTree());
					DebugLocation(135, 97);
					adaptor.AddChild(root_1, stream_something.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:136:5: BREAK
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(136, 5);
				BREAK59=(IToken)Match(input,BREAK,Follow._BREAK_in_texpr1131); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BREAK59_tree = (object)adaptor.Create(BREAK59);
				adaptor.AddChild(root_0, BREAK59_tree);
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:137:5: LET declaration_list 'in' ( expr_seq )? 'end'
				{
				DebugLocation(137, 5);
				LET60=(IToken)Match(input,LET,Follow._LET_in_texpr1137); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LET.Add(LET60);

				DebugLocation(137, 9);
				PushFollow(Follow._declaration_list_in_texpr1139);
				declaration_list61=declaration_list();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_declaration_list.Add(declaration_list61.Tree);
				DebugLocation(137, 26);
				string_literal62=(IToken)Match(input,62,Follow._62_in_texpr1141); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(string_literal62);

				DebugLocation(137, 31);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:137:31: ( expr_seq )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==BREAK||LA12_0==FOR||LA12_0==ID||(LA12_0>=INT && LA12_0<=LET)||LA12_0==MINUS||LA12_0==NIL||LA12_0==STRING||LA12_0==WHILE||LA12_0==49||LA12_0==61))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:137:31: expr_seq
					{
					DebugLocation(137, 31);
					PushFollow(Follow._expr_seq_in_texpr1143);
					expr_seq63=expr_seq();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_seq.Add(expr_seq63.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(137, 41);
				string_literal64=(IToken)Match(input,59,Follow._59_in_texpr1146); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_59.Add(string_literal64);



				{
				// AST REWRITE
				// elements: LET, expr_seq, declaration_list
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 137:47: -> ^( LET declaration_list ( expr_seq )? )
				{
					DebugLocation(137, 50);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:137:50: ^( LET declaration_list ( expr_seq )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(137, 52);
					root_1 = (object)adaptor.BecomeRoot(stream_LET.NextNode(), root_1);

					DebugLocation(137, 56);
					adaptor.AddChild(root_1, stream_declaration_list.NextTree());
					DebugLocation(137, 73);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:137:73: ( expr_seq )?
					if (stream_expr_seq.HasNext)
					{
						DebugLocation(137, 73);
						adaptor.AddChild(root_1, stream_expr_seq.NextTree());

					}
					stream_expr_seq.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:138:5: MINUS texpr
				{
				DebugLocation(138, 5);
				MINUS65=(IToken)Match(input,MINUS,Follow._MINUS_in_texpr1163); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS65);

				DebugLocation(138, 11);
				PushFollow(Follow._texpr_in_texpr1165);
				texpr66=texpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_texpr.Add(texpr66.Tree);


				{
				// AST REWRITE
				// elements: texpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 138:17: -> ^( UMINUS texpr )
				{
					DebugLocation(138, 20);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:138:20: ^( UMINUS texpr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(138, 22);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(UMINUS, "UMINUS"), root_1);

					DebugLocation(138, 29);
					adaptor.AddChild(root_1, stream_texpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("texpr", 8);
			LeaveRule("texpr", 8);
			LeaveRule_texpr();
		}
		DebugLocation(139, 2);
		} finally { DebugExitRule(GrammarFileName, "texpr"); }
		return retval;

	}
	// $ANTLR end "texpr"

	partial void EnterRule_type_id();
	partial void LeaveRule_type_id();

	// $ANTLR start "type_id"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:142:1: type_id : ID -> ^( TYPE_ID ID ) ;
	[GrammarRule("type_id")]
	private AstParserRuleReturnScope<object, IToken> type_id()
	{
		EnterRule_type_id();
		EnterRule("type_id", 9);
		TraceIn("type_id", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID67 = default(IToken);

		object ID67_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "type_id");
		DebugLocation(142, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:142:9: ( ID -> ^( TYPE_ID ID ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:142:12: ID
			{
			DebugLocation(142, 12);
			ID67=(IToken)Match(input,ID,Follow._ID_in_type_id1186); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID67);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 142:15: -> ^( TYPE_ID ID )
			{
				DebugLocation(142, 18);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:142:18: ^( TYPE_ID ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(142, 20);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_ID, "TYPE_ID"), root_1);

				DebugLocation(142, 28);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_id", 9);
			LeaveRule("type_id", 9);
			LeaveRule_type_id();
		}
		DebugLocation(143, 1);
		} finally { DebugExitRule(GrammarFileName, "type_id"); }
		return retval;

	}
	// $ANTLR end "type_id"

	partial void EnterRule_type_declaration();
	partial void LeaveRule_type_declaration();

	// $ANTLR start "type_declaration"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:145:1: type_declaration : 'type' type_id EQUAL type -> ^( TYPE_DECL type_id type ) ;
	[GrammarRule("type_declaration")]
	private AstParserRuleReturnScope<object, IToken> type_declaration()
	{
		EnterRule_type_declaration();
		EnterRule("type_declaration", 10);
		TraceIn("type_declaration", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal68 = default(IToken);
		IToken EQUAL70 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id69 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type71 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal68_tree = default(object);
		object EQUAL70_tree = default(object);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type_declaration");
		DebugLocation(145, 56);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:145:17: ( 'type' type_id EQUAL type -> ^( TYPE_DECL type_id type ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:146:3: 'type' type_id EQUAL type
			{
			DebugLocation(146, 3);
			string_literal68=(IToken)Match(input,66,Follow._66_in_type_declaration1206); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_66.Add(string_literal68);

			DebugLocation(146, 10);
			PushFollow(Follow._type_id_in_type_declaration1208);
			type_id69=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id69.Tree);
			DebugLocation(146, 18);
			EQUAL70=(IToken)Match(input,EQUAL,Follow._EQUAL_in_type_declaration1210); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQUAL.Add(EQUAL70);

			DebugLocation(146, 24);
			PushFollow(Follow._type_in_type_declaration1212);
			type71=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type71.Tree);


			{
			// AST REWRITE
			// elements: type, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 146:29: -> ^( TYPE_DECL type_id type )
			{
				DebugLocation(146, 32);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:146:32: ^( TYPE_DECL type_id type )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(146, 34);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_DECL, "TYPE_DECL"), root_1);

				DebugLocation(146, 44);
				adaptor.AddChild(root_1, stream_type_id.NextTree());
				DebugLocation(146, 52);
				adaptor.AddChild(root_1, stream_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_declaration", 10);
			LeaveRule("type_declaration", 10);
			LeaveRule_type_declaration();
		}
		DebugLocation(146, 56);
		} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
		return retval;

	}
	// $ANTLR end "type_declaration"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:148:1: type : ( type_id -> ALIAS_DECL | '{' type_fields '}' -> ^( RECORD_DECL type_fields ) | 'array' 'of' type_id -> ^( ARRAY_TYPE_DECL type_id ) );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 11);
		TraceIn("type", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal73 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken string_literal76 = default(IToken);
		IToken string_literal77 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id72 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_fields74 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id78 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal73_tree = default(object);
		object char_literal75_tree = default(object);
		object string_literal76_tree = default(object);
		object string_literal77_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(148, 53);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:148:5: ( type_id -> ALIAS_DECL | '{' type_fields '}' -> ^( RECORD_DECL type_fields ) | 'array' 'of' type_id -> ^( ARRAY_TYPE_DECL type_id ) )
			int alt14=3;
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt14 = 1;
				}
				break;
			case 68:
				{
				alt14 = 2;
				}
				break;
			case 56:
				{
				alt14 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:148:8: type_id
				{
				DebugLocation(148, 8);
				PushFollow(Follow._type_id_in_type1230);
				type_id72=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id72.Tree);


				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 148:16: -> ALIAS_DECL
				{
					DebugLocation(148, 19);
					adaptor.AddChild(root_0, (object)adaptor.Create(ALIAS_DECL, "ALIAS_DECL"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:149:4: '{' type_fields '}'
				{
				DebugLocation(149, 4);
				char_literal73=(IToken)Match(input,68,Follow._68_in_type1239); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_68.Add(char_literal73);

				DebugLocation(149, 8);
				PushFollow(Follow._type_fields_in_type1241);
				type_fields74=type_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_fields.Add(type_fields74.Tree);
				DebugLocation(149, 20);
				char_literal75=(IToken)Match(input,69,Follow._69_in_type1243); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_69.Add(char_literal75);



				{
				// AST REWRITE
				// elements: type_fields
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 149:24: -> ^( RECORD_DECL type_fields )
				{
					DebugLocation(149, 27);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:149:27: ^( RECORD_DECL type_fields )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(149, 29);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_DECL, "RECORD_DECL"), root_1);

					DebugLocation(149, 41);
					adaptor.AddChild(root_1, stream_type_fields.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:150:4: 'array' 'of' type_id
				{
				DebugLocation(150, 4);
				string_literal76=(IToken)Match(input,56,Follow._56_in_type1256); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(string_literal76);

				DebugLocation(150, 12);
				string_literal77=(IToken)Match(input,63,Follow._63_in_type1258); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal77);

				DebugLocation(150, 17);
				PushFollow(Follow._type_id_in_type1260);
				type_id78=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id78.Tree);


				{
				// AST REWRITE
				// elements: type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 150:25: -> ^( ARRAY_TYPE_DECL type_id )
				{
					DebugLocation(150, 28);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:150:28: ^( ARRAY_TYPE_DECL type_id )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(150, 30);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_TYPE_DECL, "ARRAY_TYPE_DECL"), root_1);

					DebugLocation(150, 46);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 11);
			LeaveRule("type", 11);
			LeaveRule_type();
		}
		DebugLocation(150, 53);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_type_fields();
	partial void LeaveRule_type_fields();

	// $ANTLR start "type_fields"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:152:1: type_fields : type_field ( ',' type_field )* ;
	[GrammarRule("type_fields")]
	private AstParserRuleReturnScope<object, IToken> type_fields()
	{
		EnterRule_type_fields();
		EnterRule("type_fields", 12);
		TraceIn("type_fields", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal80 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_field79 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_field81 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal80_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_fields");
		DebugLocation(152, 30);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:152:12: ( type_field ( ',' type_field )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:153:3: type_field ( ',' type_field )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(153, 3);
			PushFollow(Follow._type_field_in_type_fields1278);
			type_field79=type_field();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, type_field79.Tree);
			DebugLocation(153, 14);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:153:14: ( ',' type_field )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==51))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:153:15: ',' type_field
					{
					DebugLocation(153, 15);
					char_literal80=(IToken)Match(input,51,Follow._51_in_type_fields1281); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal80_tree = (object)adaptor.Create(char_literal80);
					adaptor.AddChild(root_0, char_literal80_tree);
					}
					DebugLocation(153, 19);
					PushFollow(Follow._type_field_in_type_fields1283);
					type_field81=type_field();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, type_field81.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_fields", 12);
			LeaveRule("type_fields", 12);
			LeaveRule_type_fields();
		}
		DebugLocation(153, 30);
		} finally { DebugExitRule(GrammarFileName, "type_fields"); }
		return retval;

	}
	// $ANTLR end "type_fields"

	partial void EnterRule_type_field();
	partial void LeaveRule_type_field();

	// $ANTLR start "type_field"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:155:1: type_field : ID ':' type_id ;
	[GrammarRule("type_field")]
	private AstParserRuleReturnScope<object, IToken> type_field()
	{
		EnterRule_type_field();
		EnterRule("type_field", 13);
		TraceIn("type_field", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID82 = default(IToken);
		IToken char_literal83 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id84 = default(AstParserRuleReturnScope<object, IToken>);

		object ID82_tree = default(object);
		object char_literal83_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_field");
		DebugLocation(155, 16);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:155:11: ( ID ':' type_id )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:156:3: ID ':' type_id
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(156, 3);
			ID82=(IToken)Match(input,ID,Follow._ID_in_type_field1295); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID82_tree = (object)adaptor.Create(ID82);
			adaptor.AddChild(root_0, ID82_tree);
			}
			DebugLocation(156, 6);
			char_literal83=(IToken)Match(input,52,Follow._52_in_type_field1297); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal83_tree = (object)adaptor.Create(char_literal83);
			adaptor.AddChild(root_0, char_literal83_tree);
			}
			DebugLocation(156, 10);
			PushFollow(Follow._type_id_in_type_field1299);
			type_id84=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, type_id84.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_field", 13);
			LeaveRule("type_field", 13);
			LeaveRule_type_field();
		}
		DebugLocation(156, 16);
		} finally { DebugExitRule(GrammarFileName, "type_field"); }
		return retval;

	}
	// $ANTLR end "type_field"

	partial void EnterRule_expr_seq();
	partial void LeaveRule_expr_seq();

	// $ANTLR start "expr_seq"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:159:1: expr_seq : expr ( ';' ! expr )* ;
	[GrammarRule("expr_seq")]
	private AstParserRuleReturnScope<object, IToken> expr_seq()
	{
		EnterRule_expr_seq();
		EnterRule("expr_seq", 14);
		TraceIn("expr_seq", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal86 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr87 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal86_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr_seq");
		DebugLocation(159, 28);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:159:9: ( expr ( ';' ! expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:159:12: expr ( ';' ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(159, 12);
			PushFollow(Follow._expr_in_expr_seq1309);
			expr85=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expr85.Tree);
			DebugLocation(159, 17);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:159:17: ( ';' ! expr )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==53))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:159:18: ';' ! expr
					{
					DebugLocation(159, 21);
					char_literal86=(IToken)Match(input,53,Follow._53_in_expr_seq1312); if (state.failed) return retval;
					DebugLocation(159, 23);
					PushFollow(Follow._expr_in_expr_seq1315);
					expr87=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr87.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_seq", 14);
			LeaveRule("expr_seq", 14);
			LeaveRule_expr_seq();
		}
		DebugLocation(159, 28);
		} finally { DebugExitRule(GrammarFileName, "expr_seq"); }
		return retval;

	}
	// $ANTLR end "expr_seq"

	partial void EnterRule_expr_list();
	partial void LeaveRule_expr_list();

	// $ANTLR start "expr_list"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:1: expr_list : expr ( ',' ! expr )* ;
	[GrammarRule("expr_list")]
	private AstParserRuleReturnScope<object, IToken> expr_list()
	{
		EnterRule_expr_list();
		EnterRule("expr_list", 15);
		TraceIn("expr_list", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal89 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr88 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr90 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal89_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr_list");
		DebugLocation(161, 28);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:10: ( expr ( ',' ! expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:12: expr ( ',' ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(161, 12);
			PushFollow(Follow._expr_in_expr_list1324);
			expr88=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expr88.Tree);
			DebugLocation(161, 17);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:17: ( ',' ! expr )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==51))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:18: ',' ! expr
					{
					DebugLocation(161, 21);
					char_literal89=(IToken)Match(input,51,Follow._51_in_expr_list1327); if (state.failed) return retval;
					DebugLocation(161, 23);
					PushFollow(Follow._expr_in_expr_list1330);
					expr90=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr90.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_list", 15);
			LeaveRule("expr_list", 15);
			LeaveRule_expr_list();
		}
		DebugLocation(161, 28);
		} finally { DebugExitRule(GrammarFileName, "expr_list"); }
		return retval;

	}
	// $ANTLR end "expr_list"

	partial void EnterRule_field_list();
	partial void LeaveRule_field_list();

	// $ANTLR start "field_list"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:1: field_list : ( ID EQUAL ! expr ) ( ',' ! ID EQUAL ! expr )* ;
	[GrammarRule("field_list")]
	private AstParserRuleReturnScope<object, IToken> field_list()
	{
		EnterRule_field_list();
		EnterRule("field_list", 16);
		TraceIn("field_list", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID91 = default(IToken);
		IToken EQUAL92 = default(IToken);
		IToken char_literal94 = default(IToken);
		IToken ID95 = default(IToken);
		IToken EQUAL96 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr93 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr97 = default(AstParserRuleReturnScope<object, IToken>);

		object ID91_tree = default(object);
		object EQUAL92_tree = default(object);
		object char_literal94_tree = default(object);
		object ID95_tree = default(object);
		object EQUAL96_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "field_list");
		DebugLocation(163, 41);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:11: ( ( ID EQUAL ! expr ) ( ',' ! ID EQUAL ! expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:164:3: ( ID EQUAL ! expr ) ( ',' ! ID EQUAL ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(164, 3);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:164:3: ( ID EQUAL ! expr )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:164:4: ID EQUAL ! expr
			{
			DebugLocation(164, 4);
			ID91=(IToken)Match(input,ID,Follow._ID_in_field_list1344); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID91_tree = (object)adaptor.Create(ID91);
			adaptor.AddChild(root_0, ID91_tree);
			}
			DebugLocation(164, 12);
			EQUAL92=(IToken)Match(input,EQUAL,Follow._EQUAL_in_field_list1346); if (state.failed) return retval;
			DebugLocation(164, 14);
			PushFollow(Follow._expr_in_field_list1349);
			expr93=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expr93.Tree);

			}

			DebugLocation(164, 20);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:164:20: ( ',' ! ID EQUAL ! expr )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==51))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:164:21: ',' ! ID EQUAL ! expr
					{
					DebugLocation(164, 24);
					char_literal94=(IToken)Match(input,51,Follow._51_in_field_list1353); if (state.failed) return retval;
					DebugLocation(164, 26);
					ID95=(IToken)Match(input,ID,Follow._ID_in_field_list1356); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ID95_tree = (object)adaptor.Create(ID95);
					adaptor.AddChild(root_0, ID95_tree);
					}
					DebugLocation(164, 34);
					EQUAL96=(IToken)Match(input,EQUAL,Follow._EQUAL_in_field_list1358); if (state.failed) return retval;
					DebugLocation(164, 36);
					PushFollow(Follow._expr_in_field_list1361);
					expr97=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr97.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("field_list", 16);
			LeaveRule("field_list", 16);
			LeaveRule_field_list();
		}
		DebugLocation(164, 41);
		} finally { DebugExitRule(GrammarFileName, "field_list"); }
		return retval;

	}
	// $ANTLR end "field_list"

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();

	// $ANTLR start "lvalue"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:166:1: lvalue : ID ( array_or_member_access )? -> ^( LVALUE ID ( array_or_member_access )? ) ;
	[GrammarRule("lvalue")]
	private AstParserRuleReturnScope<object, IToken> lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 17);
		TraceIn("lvalue", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID98 = default(IToken);
		AstParserRuleReturnScope<object, IToken> array_or_member_access99 = default(AstParserRuleReturnScope<object, IToken>);

		object ID98_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_array_or_member_access=new RewriteRuleSubtreeStream(adaptor,"rule array_or_member_access");
		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(166, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:166:8: ( ID ( array_or_member_access )? -> ^( LVALUE ID ( array_or_member_access )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:166:10: ID ( array_or_member_access )?
			{
			DebugLocation(166, 10);
			ID98=(IToken)Match(input,ID,Follow._ID_in_lvalue1372); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID98);

			DebugLocation(166, 13);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:166:13: ( array_or_member_access )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==DOT||LA19_0==54))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:166:13: array_or_member_access
				{
				DebugLocation(166, 13);
				PushFollow(Follow._array_or_member_access_in_lvalue1374);
				array_or_member_access99=array_or_member_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_array_or_member_access.Add(array_or_member_access99.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(19); }



			{
			// AST REWRITE
			// elements: array_or_member_access, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 166:37: -> ^( LVALUE ID ( array_or_member_access )? )
			{
				DebugLocation(166, 40);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:166:40: ^( LVALUE ID ( array_or_member_access )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(166, 42);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LVALUE, "LVALUE"), root_1);

				DebugLocation(166, 49);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(166, 52);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:166:52: ( array_or_member_access )?
				if (stream_array_or_member_access.HasNext)
				{
					DebugLocation(166, 52);
					adaptor.AddChild(root_1, stream_array_or_member_access.NextTree());

				}
				stream_array_or_member_access.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lvalue", 17);
			LeaveRule("lvalue", 17);
			LeaveRule_lvalue();
		}
		DebugLocation(167, 1);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"

	partial void EnterRule_array_or_member_access();
	partial void LeaveRule_array_or_member_access();

	// $ANTLR start "array_or_member_access"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:169:1: array_or_member_access : ( member_access | array_access ) ( array_or_member_access )? ;
	[GrammarRule("array_or_member_access")]
	private AstParserRuleReturnScope<object, IToken> array_or_member_access()
	{
		EnterRule_array_or_member_access();
		EnterRule("array_or_member_access", 18);
		TraceIn("array_or_member_access", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> member_access100 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> array_access101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> array_or_member_access102 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "array_or_member_access");
		DebugLocation(169, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:170:2: ( ( member_access | array_access ) ( array_or_member_access )? )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:170:4: ( member_access | array_access ) ( array_or_member_access )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(170, 4);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:170:4: ( member_access | array_access )
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==DOT))
			{
				alt20 = 1;
			}
			else if ((LA20_0==54))
			{
				alt20 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:170:5: member_access
				{
				DebugLocation(170, 5);
				PushFollow(Follow._member_access_in_array_or_member_access1399);
				member_access100=member_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, member_access100.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:170:21: array_access
				{
				DebugLocation(170, 21);
				PushFollow(Follow._array_access_in_array_or_member_access1403);
				array_access101=array_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_access101.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(170, 35);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:170:35: ( array_or_member_access )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==DOT||LA21_0==54))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:170:35: array_or_member_access
				{
				DebugLocation(170, 35);
				PushFollow(Follow._array_or_member_access_in_array_or_member_access1406);
				array_or_member_access102=array_or_member_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_or_member_access102.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array_or_member_access", 18);
			LeaveRule("array_or_member_access", 18);
			LeaveRule_array_or_member_access();
		}
		DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "array_or_member_access"); }
		return retval;

	}
	// $ANTLR end "array_or_member_access"

	partial void EnterRule_member_access();
	partial void LeaveRule_member_access();

	// $ANTLR start "member_access"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:173:1: member_access : DOT ^ ID ;
	[GrammarRule("member_access")]
	private AstParserRuleReturnScope<object, IToken> member_access()
	{
		EnterRule_member_access();
		EnterRule("member_access", 19);
		TraceIn("member_access", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT103 = default(IToken);
		IToken ID104 = default(IToken);

		object DOT103_tree = default(object);
		object ID104_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "member_access");
		DebugLocation(173, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:174:2: ( DOT ^ ID )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:174:4: DOT ^ ID
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(174, 7);
			DOT103=(IToken)Match(input,DOT,Follow._DOT_in_member_access1419); if (state.failed) return retval;
			if (state.backtracking == 0) {
			DOT103_tree = (object)adaptor.Create(DOT103);
			root_0 = (object)adaptor.BecomeRoot(DOT103_tree, root_0);
			}
			DebugLocation(174, 9);
			ID104=(IToken)Match(input,ID,Follow._ID_in_member_access1422); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID104_tree = (object)adaptor.Create(ID104);
			adaptor.AddChild(root_0, ID104_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("member_access", 19);
			LeaveRule("member_access", 19);
			LeaveRule_member_access();
		}
		DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "member_access"); }
		return retval;

	}
	// $ANTLR end "member_access"

	partial void EnterRule_array_access();
	partial void LeaveRule_array_access();

	// $ANTLR start "array_access"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:177:1: array_access : '[' expr ']' -> ^( AT expr ) ;
	[GrammarRule("array_access")]
	private AstParserRuleReturnScope<object, IToken> array_access()
	{
		EnterRule_array_access();
		EnterRule("array_access", 20);
		TraceIn("array_access", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal105 = default(IToken);
		IToken char_literal107 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr106 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal105_tree = default(object);
		object char_literal107_tree = default(object);
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "array_access");
		DebugLocation(177, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:178:2: ( '[' expr ']' -> ^( AT expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:178:4: '[' expr ']'
			{
			DebugLocation(178, 4);
			char_literal105=(IToken)Match(input,54,Follow._54_in_array_access1434); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_54.Add(char_literal105);

			DebugLocation(178, 8);
			PushFollow(Follow._expr_in_array_access1436);
			expr106=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr106.Tree);
			DebugLocation(178, 13);
			char_literal107=(IToken)Match(input,55,Follow._55_in_array_access1438); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_55.Add(char_literal107);



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 178:17: -> ^( AT expr )
			{
				DebugLocation(178, 20);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:178:20: ^( AT expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(178, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(AT, "AT"), root_1);

				DebugLocation(178, 25);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array_access", 20);
			LeaveRule("array_access", 20);
			LeaveRule_array_access();
		}
		DebugLocation(179, 1);
		} finally { DebugExitRule(GrammarFileName, "array_access"); }
		return retval;

	}
	// $ANTLR end "array_access"

	partial void EnterRule_declaration_list();
	partial void LeaveRule_declaration_list();

	// $ANTLR start "declaration_list"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:181:1: declaration_list : ( declaration )+ ;
	[GrammarRule("declaration_list")]
	private AstParserRuleReturnScope<object, IToken> declaration_list()
	{
		EnterRule_declaration_list();
		EnterRule("declaration_list", 21);
		TraceIn("declaration_list", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration108 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration_list");
		DebugLocation(181, 16);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:181:17: ( ( declaration )+ )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:182:3: ( declaration )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(182, 3);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:182:3: ( declaration )+
			int cnt22=0;
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==60||(LA22_0>=66 && LA22_0<=67)))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:182:4: declaration
					{
					DebugLocation(182, 4);
					PushFollow(Follow._declaration_in_declaration_list1459);
					declaration108=declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declaration108.Tree);

					}
					break;

				default:
					if (cnt22 >= 1)
						goto loop22;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee22 = new EarlyExitException( 22, input );
					DebugRecognitionException(eee22);
					throw eee22;
				}
				cnt22++;
			}
			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_list", 21);
			LeaveRule("declaration_list", 21);
			LeaveRule_declaration_list();
		}
		DebugLocation(182, 16);
		} finally { DebugExitRule(GrammarFileName, "declaration_list"); }
		return retval;

	}
	// $ANTLR end "declaration_list"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:183:1: declaration : ( type_declaration | variable_declaration | function_declaration );
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<object, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 22);
		TraceIn("declaration", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_declaration109 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variable_declaration110 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_declaration111 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(183, 23);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:183:12: ( type_declaration | variable_declaration | function_declaration )
			int alt23=3;
			try { DebugEnterDecision(23, false);
			switch (input.LA(1))
			{
			case 66:
				{
				alt23 = 1;
				}
				break;
			case 67:
				{
				alt23 = 2;
				}
				break;
			case 60:
				{
				alt23 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:184:3: type_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(184, 3);
				PushFollow(Follow._type_declaration_in_declaration1469);
				type_declaration109=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration109.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:185:4: variable_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(185, 4);
				PushFollow(Follow._variable_declaration_in_declaration1474);
				variable_declaration110=variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variable_declaration110.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:186:4: function_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(186, 4);
				PushFollow(Follow._function_declaration_in_declaration1479);
				function_declaration111=function_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_declaration111.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 22);
			LeaveRule("declaration", 22);
			LeaveRule_declaration();
		}
		DebugLocation(186, 23);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_variable_declaration();
	partial void LeaveRule_variable_declaration();

	// $ANTLR start "variable_declaration"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:188:1: variable_declaration : 'var' ID ( ':' type_id )? ASSIGN expr -> ^( VAR_DECL ID ( type_id )? expr ) ;
	[GrammarRule("variable_declaration")]
	private AstParserRuleReturnScope<object, IToken> variable_declaration()
	{
		EnterRule_variable_declaration();
		EnterRule("variable_declaration", 23);
		TraceIn("variable_declaration", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal112 = default(IToken);
		IToken ID113 = default(IToken);
		IToken char_literal114 = default(IToken);
		IToken ASSIGN116 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id115 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr117 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal112_tree = default(object);
		object ID113_tree = default(object);
		object char_literal114_tree = default(object);
		object ASSIGN116_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "variable_declaration");
		DebugLocation(188, 69);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:188:21: ( 'var' ID ( ':' type_id )? ASSIGN expr -> ^( VAR_DECL ID ( type_id )? expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:3: 'var' ID ( ':' type_id )? ASSIGN expr
			{
			DebugLocation(189, 3);
			string_literal112=(IToken)Match(input,67,Follow._67_in_variable_declaration1489); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_67.Add(string_literal112);

			DebugLocation(189, 9);
			ID113=(IToken)Match(input,ID,Follow._ID_in_variable_declaration1491); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID113);

			DebugLocation(189, 12);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:12: ( ':' type_id )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==52))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:13: ':' type_id
				{
				DebugLocation(189, 13);
				char_literal114=(IToken)Match(input,52,Follow._52_in_variable_declaration1494); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal114);

				DebugLocation(189, 17);
				PushFollow(Follow._type_id_in_variable_declaration1496);
				type_id115=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id115.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(189, 27);
			ASSIGN116=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variable_declaration1500); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN116);

			DebugLocation(189, 34);
			PushFollow(Follow._expr_in_variable_declaration1502);
			expr117=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr117.Tree);


			{
			// AST REWRITE
			// elements: expr, type_id, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 189:39: -> ^( VAR_DECL ID ( type_id )? expr )
			{
				DebugLocation(189, 42);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:42: ^( VAR_DECL ID ( type_id )? expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(189, 44);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR_DECL, "VAR_DECL"), root_1);

				DebugLocation(189, 53);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(189, 56);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:56: ( type_id )?
				if (stream_type_id.HasNext)
				{
					DebugLocation(189, 56);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

				}
				stream_type_id.Reset();
				DebugLocation(189, 65);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable_declaration", 23);
			LeaveRule("variable_declaration", 23);
			LeaveRule_variable_declaration();
		}
		DebugLocation(189, 69);
		} finally { DebugExitRule(GrammarFileName, "variable_declaration"); }
		return retval;

	}
	// $ANTLR end "variable_declaration"

	partial void EnterRule_function_declaration();
	partial void LeaveRule_function_declaration();

	// $ANTLR start "function_declaration"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:191:1: function_declaration : 'function' ID '(' ( type_fields )? ')' ( ':' type_id )? EQUAL expr -> ^( FUNCTION_DECL ID ( type_fields )? ( type_id )? expr ) ;
	[GrammarRule("function_declaration")]
	private AstParserRuleReturnScope<object, IToken> function_declaration()
	{
		EnterRule_function_declaration();
		EnterRule("function_declaration", 24);
		TraceIn("function_declaration", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal118 = default(IToken);
		IToken ID119 = default(IToken);
		IToken char_literal120 = default(IToken);
		IToken char_literal122 = default(IToken);
		IToken char_literal123 = default(IToken);
		IToken EQUAL125 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_fields121 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id124 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr126 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal118_tree = default(object);
		object ID119_tree = default(object);
		object char_literal120_tree = default(object);
		object char_literal122_tree = default(object);
		object char_literal123_tree = default(object);
		object EQUAL125_tree = default(object);
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "function_declaration");
		DebugLocation(191, 112);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:191:21: ( 'function' ID '(' ( type_fields )? ')' ( ':' type_id )? EQUAL expr -> ^( FUNCTION_DECL ID ( type_fields )? ( type_id )? expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:192:3: 'function' ID '(' ( type_fields )? ')' ( ':' type_id )? EQUAL expr
			{
			DebugLocation(192, 3);
			string_literal118=(IToken)Match(input,60,Follow._60_in_function_declaration1524); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_60.Add(string_literal118);

			DebugLocation(192, 14);
			ID119=(IToken)Match(input,ID,Follow._ID_in_function_declaration1526); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID119);

			DebugLocation(192, 17);
			char_literal120=(IToken)Match(input,49,Follow._49_in_function_declaration1528); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal120);

			DebugLocation(192, 21);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:192:21: ( type_fields )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_0 = input.LA(1);

			if ((LA25_0==ID))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:192:21: type_fields
				{
				DebugLocation(192, 21);
				PushFollow(Follow._type_fields_in_function_declaration1530);
				type_fields121=type_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_fields.Add(type_fields121.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(192, 34);
			char_literal122=(IToken)Match(input,50,Follow._50_in_function_declaration1533); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_50.Add(char_literal122);

			DebugLocation(192, 38);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:192:38: ( ':' type_id )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==52))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:192:39: ':' type_id
				{
				DebugLocation(192, 39);
				char_literal123=(IToken)Match(input,52,Follow._52_in_function_declaration1536); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal123);

				DebugLocation(192, 43);
				PushFollow(Follow._type_id_in_function_declaration1538);
				type_id124=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id124.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(192, 53);
			EQUAL125=(IToken)Match(input,EQUAL,Follow._EQUAL_in_function_declaration1542); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQUAL.Add(EQUAL125);

			DebugLocation(192, 59);
			PushFollow(Follow._expr_in_function_declaration1544);
			expr126=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr126.Tree);


			{
			// AST REWRITE
			// elements: type_fields, ID, expr, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 192:64: -> ^( FUNCTION_DECL ID ( type_fields )? ( type_id )? expr )
			{
				DebugLocation(192, 67);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:192:67: ^( FUNCTION_DECL ID ( type_fields )? ( type_id )? expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(192, 69);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_DECL, "FUNCTION_DECL"), root_1);

				DebugLocation(192, 83);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(192, 86);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:192:86: ( type_fields )?
				if (stream_type_fields.HasNext)
				{
					DebugLocation(192, 86);
					adaptor.AddChild(root_1, stream_type_fields.NextTree());

				}
				stream_type_fields.Reset();
				DebugLocation(192, 99);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:192:99: ( type_id )?
				if (stream_type_id.HasNext)
				{
					DebugLocation(192, 99);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

				}
				stream_type_id.Reset();
				DebugLocation(192, 108);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function_declaration", 24);
			LeaveRule("function_declaration", 24);
			LeaveRule_function_declaration();
		}
		DebugLocation(192, 112);
		} finally { DebugExitRule(GrammarFileName, "function_declaration"); }
		return retval;

	}
	// $ANTLR end "function_declaration"

	partial void EnterRule_synpred1_Tiger_fragment();
	partial void LeaveRule_synpred1_Tiger_fragment();

	// $ANTLR start synpred1_Tiger
	public void synpred1_Tiger_fragment()
	{
		EnterRule_synpred1_Tiger_fragment();
		EnterRule("synpred1_Tiger_fragment", 25);
		TraceIn("synpred1_Tiger_fragment", 25);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:5: ( ID '[' expr ']' 'of' )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:6: ID '[' expr ']' 'of'
			{
			DebugLocation(126, 6);
			Match(input,ID,Follow._ID_in_synpred1_Tiger802); if (state.failed) return;
			DebugLocation(126, 9);
			Match(input,54,Follow._54_in_synpred1_Tiger804); if (state.failed) return;
			DebugLocation(126, 13);
			PushFollow(Follow._expr_in_synpred1_Tiger806);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(126, 18);
			Match(input,55,Follow._55_in_synpred1_Tiger808); if (state.failed) return;
			DebugLocation(126, 22);
			Match(input,63,Follow._63_in_synpred1_Tiger810); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Tiger_fragment", 25);
			LeaveRule("synpred1_Tiger_fragment", 25);
			LeaveRule_synpred1_Tiger_fragment();
		}
	}
	// $ANTLR end synpred1_Tiger

	partial void EnterRule_synpred2_Tiger_fragment();
	partial void LeaveRule_synpred2_Tiger_fragment();

	// $ANTLR start synpred2_Tiger
	public void synpred2_Tiger_fragment()
	{
		EnterRule_synpred2_Tiger_fragment();
		EnterRule("synpred2_Tiger_fragment", 26);
		TraceIn("synpred2_Tiger_fragment", 26);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:5: ( ID '(' )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:6: ID '('
			{
			DebugLocation(127, 6);
			Match(input,ID,Follow._ID_in_synpred2_Tiger851); if (state.failed) return;
			DebugLocation(127, 9);
			Match(input,49,Follow._49_in_synpred2_Tiger853); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_Tiger_fragment", 26);
			LeaveRule("synpred2_Tiger_fragment", 26);
			LeaveRule_synpred2_Tiger_fragment();
		}
	}
	// $ANTLR end synpred2_Tiger

	partial void EnterRule_synpred3_Tiger_fragment();
	partial void LeaveRule_synpred3_Tiger_fragment();

	// $ANTLR start synpred3_Tiger
	public void synpred3_Tiger_fragment()
	{
		EnterRule_synpred3_Tiger_fragment();
		EnterRule("synpred3_Tiger_fragment", 27);
		TraceIn("synpred3_Tiger_fragment", 27);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:5: ( ID '{' )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:6: ID '{'
			{
			DebugLocation(128, 6);
			Match(input,ID,Follow._ID_in_synpred3_Tiger887); if (state.failed) return;
			DebugLocation(128, 9);
			Match(input,68,Follow._68_in_synpred3_Tiger889); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_Tiger_fragment", 27);
			LeaveRule("synpred3_Tiger_fragment", 27);
			LeaveRule_synpred3_Tiger_fragment();
		}
	}
	// $ANTLR end synpred3_Tiger

	partial void EnterRule_synpred4_Tiger_fragment();
	partial void LeaveRule_synpred4_Tiger_fragment();

	// $ANTLR start synpred4_Tiger
	public void synpred4_Tiger_fragment()
	{
		EnterRule_synpred4_Tiger_fragment();
		EnterRule("synpred4_Tiger_fragment", 28);
		TraceIn("synpred4_Tiger_fragment", 28);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:5: ( lvalue ASSIGN )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:6: lvalue ASSIGN
			{
			DebugLocation(129, 6);
			PushFollow(Follow._lvalue_in_synpred4_Tiger921);
			lvalue();
			PopFollow();
			if (state.failed) return;
			DebugLocation(129, 13);
			Match(input,ASSIGN,Follow._ASSIGN_in_synpred4_Tiger923); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_Tiger_fragment", 28);
			LeaveRule("synpred4_Tiger_fragment", 28);
			LeaveRule_synpred4_Tiger_fragment();
		}
	}
	// $ANTLR end synpred4_Tiger

	partial void EnterRule_synpred5_Tiger_fragment();
	partial void LeaveRule_synpred5_Tiger_fragment();

	// $ANTLR start synpred5_Tiger
	public void synpred5_Tiger_fragment()
	{
		EnterRule_synpred5_Tiger_fragment();
		EnterRule("synpred5_Tiger_fragment", 29);
		TraceIn("synpred5_Tiger_fragment", 29);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:132:5: ( 'if' expr 'then' expr 'else' )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:132:6: 'if' expr 'then' expr 'else'
			{
			DebugLocation(132, 6);
			Match(input,61,Follow._61_in_synpred5_Tiger977); if (state.failed) return;
			DebugLocation(132, 11);
			PushFollow(Follow._expr_in_synpred5_Tiger979);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(132, 16);
			Match(input,64,Follow._64_in_synpred5_Tiger981); if (state.failed) return;
			DebugLocation(132, 23);
			PushFollow(Follow._expr_in_synpred5_Tiger983);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(132, 28);
			Match(input,58,Follow._58_in_synpred5_Tiger985); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_Tiger_fragment", 29);
			LeaveRule("synpred5_Tiger_fragment", 29);
			LeaveRule_synpred5_Tiger_fragment();
		}
	}
	// $ANTLR end synpred5_Tiger
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expr_in_program628 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _or_expr_in_expr646 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _and_exp_in_or_expr654 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _OR_in_or_expr657 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _and_exp_in_or_expr660 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _comp_expr_in_and_exp672 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _AND_in_and_exp675 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _comp_expr_in_and_exp678 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _arith_expr_in_comp_expr691 = new BitSet(new ulong[]{0x860C08002UL});
		public static readonly BitSet _EQUAL_in_comp_expr694 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _NON_EQUAL_in_comp_expr699 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _LT_in_comp_expr704 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _GT_in_comp_expr709 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _LT_EQUAL_in_comp_expr714 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _GT_EQUAL_in_comp_expr719 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _arith_expr_in_comp_expr723 = new BitSet(new ulong[]{0x860C08002UL});
		public static readonly BitSet _term_in_arith_expr736 = new BitSet(new ulong[]{0x2100000002UL});
		public static readonly BitSet _PLUS_in_arith_expr739 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _MINUS_in_arith_expr742 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _term_in_arith_expr746 = new BitSet(new ulong[]{0x2100000002UL});
		public static readonly BitSet _texpr_in_term758 = new BitSet(new ulong[]{0x200002002UL});
		public static readonly BitSet _MUL_in_term761 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _DIV_in_term764 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _texpr_in_term768 = new BitSet(new ulong[]{0x200002002UL});
		public static readonly BitSet _STRING_in_texpr783 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_texpr789 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NIL_in_texpr795 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_texpr815 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_texpr817 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr821 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _55_in_texpr823 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_texpr825 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr829 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_texpr857 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_texpr859 = new BitSet(new ulong[]{0x2006840519080800UL});
		public static readonly BitSet _expr_list_in_texpr861 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _50_in_texpr864 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_texpr895 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _68_in_texpr897 = new BitSet(new ulong[]{0x1000000UL,0x20UL});
		public static readonly BitSet _field_list_in_texpr899 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _69_in_texpr902 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_texpr929 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_texpr931 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr933 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_texpr950 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _49_in_texpr956 = new BitSet(new ulong[]{0x2006840519080800UL});
		public static readonly BitSet _expr_seq_in_texpr958 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _50_in_texpr961 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _61_in_texpr991 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr995 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_texpr997 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1001 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_texpr1003 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1007 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _61_in_texpr1029 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1033 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_texpr1035 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1039 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_texpr1057 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1061 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_texpr1063 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1067 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_texpr1085 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _ID_in_texpr1089 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_texpr1091 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1095 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _65_in_texpr1097 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1101 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_texpr1103 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_texpr1107 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_texpr1131 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_texpr1137 = new BitSet(new ulong[]{0x1000000000000000UL,0xCUL});
		public static readonly BitSet _declaration_list_in_texpr1139 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_texpr1141 = new BitSet(new ulong[]{0x2802840519080800UL});
		public static readonly BitSet _expr_seq_in_texpr1143 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _59_in_texpr1146 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_texpr1163 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _texpr_in_texpr1165 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_type_id1186 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_type_declaration1206 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _type_id_in_type_declaration1208 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _EQUAL_in_type_declaration1210 = new BitSet(new ulong[]{0x100000001000000UL,0x10UL});
		public static readonly BitSet _type_in_type_declaration1212 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_type1230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_type1239 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _type_fields_in_type1241 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _69_in_type1243 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _56_in_type1256 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_type1258 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _type_id_in_type1260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_field_in_type_fields1278 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _51_in_type_fields1281 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _type_field_in_type_fields1283 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _ID_in_type_field1295 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_type_field1297 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _type_id_in_type_field1299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_expr_seq1309 = new BitSet(new ulong[]{0x20000000000002UL});
		public static readonly BitSet _53_in_expr_seq1312 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_expr_seq1315 = new BitSet(new ulong[]{0x20000000000002UL});
		public static readonly BitSet _expr_in_expr_list1324 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _51_in_expr_list1327 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_expr_list1330 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _ID_in_field_list1344 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _EQUAL_in_field_list1346 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_field_list1349 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _51_in_field_list1353 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _ID_in_field_list1356 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _EQUAL_in_field_list1358 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_field_list1361 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _ID_in_lvalue1372 = new BitSet(new ulong[]{0x40000000004002UL});
		public static readonly BitSet _array_or_member_access_in_lvalue1374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _member_access_in_array_or_member_access1399 = new BitSet(new ulong[]{0x40000000004002UL});
		public static readonly BitSet _array_access_in_array_or_member_access1403 = new BitSet(new ulong[]{0x40000000004002UL});
		public static readonly BitSet _array_or_member_access_in_array_or_member_access1406 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_member_access1419 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _ID_in_member_access1422 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _54_in_array_access1434 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_array_access1436 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _55_in_array_access1438 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_declaration_list1459 = new BitSet(new ulong[]{0x1000000000000002UL,0xCUL});
		public static readonly BitSet _type_declaration_in_declaration1469 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_declaration1474 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_declaration_in_declaration1479 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _67_in_variable_declaration1489 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _ID_in_variable_declaration1491 = new BitSet(new ulong[]{0x10000000000200UL});
		public static readonly BitSet _52_in_variable_declaration1494 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _type_id_in_variable_declaration1496 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_variable_declaration1500 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_variable_declaration1502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _60_in_function_declaration1524 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _ID_in_function_declaration1526 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_function_declaration1528 = new BitSet(new ulong[]{0x4000001000000UL});
		public static readonly BitSet _type_fields_in_function_declaration1530 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _50_in_function_declaration1533 = new BitSet(new ulong[]{0x10000000008000UL});
		public static readonly BitSet _52_in_function_declaration1536 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _type_id_in_function_declaration1538 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _EQUAL_in_function_declaration1542 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_function_declaration1544 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred1_Tiger802 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_synpred1_Tiger804 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_synpred1_Tiger806 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _55_in_synpred1_Tiger808 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_synpred1_Tiger810 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred2_Tiger851 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_synpred2_Tiger853 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred3_Tiger887 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _68_in_synpred3_Tiger889 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_synpred4_Tiger921 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_synpred4_Tiger923 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _61_in_synpred5_Tiger977 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_synpred5_Tiger979 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_synpred5_Tiger981 = new BitSet(new ulong[]{0x2002840519080800UL});
		public static readonly BitSet _expr_in_synpred5_Tiger983 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_synpred5_Tiger985 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
