//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g 2012-12-07 12:31:15

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class TigerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ALIAS_DECL", "AND", "ARRAY_CREATION", "ARRAY_TYPE_DECL", "ASCII_ESC", "ASSIGN", "AT", "BREAK", "COMMENT", "DIV", "EQUAL", "ESC_SEQ", "EXPRESSION_LIST", "EXPRESSION_SEQ", "FOR", "FUNCTION_CALL", "FUNCTION_DECL", "GT", "GT_EQUAL", "ID", "IF_THEN", "IF_THEN_ELSE", "INT", "LET", "LT", "LT_EQUAL", "MINUS", "MUL", "NIL", "NON_EQUAL", "OR", "PLUS", "PRINTABLE_CHARACTER", "PROGRAM", "RECORD_CREATION", "RECORD_DECL", "STRING", "TYPE_DECL", "TYPE_ID", "UMINUS", "VAR_DECL", "WHILE", "WS", "'('", "')'", "','", "'.'", "':'", "';'", "'['", "']'", "'array'", "'do'", "'else'", "'end'", "'function'", "'if'", "'in'", "'of'", "'then'", "'to'", "'type'", "'var'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int ALIAS_DECL=4;
	public const int AND=5;
	public const int ARRAY_CREATION=6;
	public const int ARRAY_TYPE_DECL=7;
	public const int ASCII_ESC=8;
	public const int ASSIGN=9;
	public const int AT=10;
	public const int BREAK=11;
	public const int COMMENT=12;
	public const int DIV=13;
	public const int EQUAL=14;
	public const int ESC_SEQ=15;
	public const int EXPRESSION_LIST=16;
	public const int EXPRESSION_SEQ=17;
	public const int FOR=18;
	public const int FUNCTION_CALL=19;
	public const int FUNCTION_DECL=20;
	public const int GT=21;
	public const int GT_EQUAL=22;
	public const int ID=23;
	public const int IF_THEN=24;
	public const int IF_THEN_ELSE=25;
	public const int INT=26;
	public const int LET=27;
	public const int LT=28;
	public const int LT_EQUAL=29;
	public const int MINUS=30;
	public const int MUL=31;
	public const int NIL=32;
	public const int NON_EQUAL=33;
	public const int OR=34;
	public const int PLUS=35;
	public const int PRINTABLE_CHARACTER=36;
	public const int PROGRAM=37;
	public const int RECORD_CREATION=38;
	public const int RECORD_DECL=39;
	public const int STRING=40;
	public const int TYPE_DECL=41;
	public const int TYPE_ID=42;
	public const int UMINUS=43;
	public const int VAR_DECL=44;
	public const int WHILE=45;
	public const int WS=46;

	public TigerParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TigerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return TigerParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:99:1: program : expr EOF -> ^( PROGRAM expr ) ;
	[GrammarRule("program")]
	private AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(99, 37);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:99:9: ( expr EOF -> ^( PROGRAM expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:99:11: expr EOF
			{
			DebugLocation(99, 11);
			PushFollow(Follow._expr_in_program616);
			expr1=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr1.Tree);
			DebugLocation(99, 16);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_program618); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 99:20: -> ^( PROGRAM expr )
			{
				DebugLocation(99, 23);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:99:23: ^( PROGRAM expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(99, 25);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(99, 33);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(99, 37);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:101:1: expr : or_expr ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 2);
		TraceIn("expr", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> or_expr3 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(101, 14);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:101:6: ( or_expr )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:101:8: or_expr
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(101, 8);
			PushFollow(Follow._or_expr_in_expr634);
			or_expr3=or_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, or_expr3.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 2);
			LeaveRule("expr", 2);
			LeaveRule_expr();
		}
		DebugLocation(101, 14);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_or_expr();
	partial void LeaveRule_or_expr();

	// $ANTLR start "or_expr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:103:1: or_expr : and_exp ( OR ^ and_exp )* ;
	[GrammarRule("or_expr")]
	private AstParserRuleReturnScope<object, IToken> or_expr()
	{
		EnterRule_or_expr();
		EnterRule("or_expr", 3);
		TraceIn("or_expr", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR5 = default(IToken);
		AstParserRuleReturnScope<object, IToken> and_exp4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> and_exp6 = default(AstParserRuleReturnScope<object, IToken>);

		object OR5_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "or_expr");
		DebugLocation(103, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:103:9: ( and_exp ( OR ^ and_exp )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:103:11: and_exp ( OR ^ and_exp )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(103, 11);
			PushFollow(Follow._and_exp_in_or_expr642);
			and_exp4=and_exp();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, and_exp4.Tree);
			DebugLocation(103, 19);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:103:19: ( OR ^ and_exp )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==OR))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:103:20: OR ^ and_exp
					{
					DebugLocation(103, 22);
					OR5=(IToken)Match(input,OR,Follow._OR_in_or_expr645); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR5_tree = (object)adaptor.Create(OR5);
					root_0 = (object)adaptor.BecomeRoot(OR5_tree, root_0);
					}
					DebugLocation(103, 24);
					PushFollow(Follow._and_exp_in_or_expr648);
					and_exp6=and_exp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, and_exp6.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("or_expr", 3);
			LeaveRule("or_expr", 3);
			LeaveRule_or_expr();
		}
		DebugLocation(104, 1);
		} finally { DebugExitRule(GrammarFileName, "or_expr"); }
		return retval;

	}
	// $ANTLR end "or_expr"

	partial void EnterRule_and_exp();
	partial void LeaveRule_and_exp();

	// $ANTLR start "and_exp"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:1: and_exp : comp_expr ( AND ^ comp_expr )* ;
	[GrammarRule("and_exp")]
	private AstParserRuleReturnScope<object, IToken> and_exp()
	{
		EnterRule_and_exp();
		EnterRule("and_exp", 4);
		TraceIn("and_exp", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND8 = default(IToken);
		AstParserRuleReturnScope<object, IToken> comp_expr7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> comp_expr9 = default(AstParserRuleReturnScope<object, IToken>);

		object AND8_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "and_exp");
		DebugLocation(106, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:9: ( comp_expr ( AND ^ comp_expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:11: comp_expr ( AND ^ comp_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(106, 11);
			PushFollow(Follow._comp_expr_in_and_exp660);
			comp_expr7=comp_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, comp_expr7.Tree);
			DebugLocation(106, 21);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:21: ( AND ^ comp_expr )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==AND))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:106:22: AND ^ comp_expr
					{
					DebugLocation(106, 25);
					AND8=(IToken)Match(input,AND,Follow._AND_in_and_exp663); if (state.failed) return retval;
					if (state.backtracking == 0) {
					AND8_tree = (object)adaptor.Create(AND8);
					root_0 = (object)adaptor.BecomeRoot(AND8_tree, root_0);
					}
					DebugLocation(106, 27);
					PushFollow(Follow._comp_expr_in_and_exp666);
					comp_expr9=comp_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, comp_expr9.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("and_exp", 4);
			LeaveRule("and_exp", 4);
			LeaveRule_and_exp();
		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "and_exp"); }
		return retval;

	}
	// $ANTLR end "and_exp"

	partial void EnterRule_comp_expr();
	partial void LeaveRule_comp_expr();

	// $ANTLR start "comp_expr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:109:1: comp_expr : arith_expr ( ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr )* ;
	[GrammarRule("comp_expr")]
	private AstParserRuleReturnScope<object, IToken> comp_expr()
	{
		EnterRule_comp_expr();
		EnterRule("comp_expr", 5);
		TraceIn("comp_expr", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQUAL11 = default(IToken);
		IToken NON_EQUAL12 = default(IToken);
		IToken LT13 = default(IToken);
		IToken GT14 = default(IToken);
		IToken LT_EQUAL15 = default(IToken);
		IToken GT_EQUAL16 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arith_expr10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arith_expr17 = default(AstParserRuleReturnScope<object, IToken>);

		object EQUAL11_tree = default(object);
		object NON_EQUAL12_tree = default(object);
		object LT13_tree = default(object);
		object GT14_tree = default(object);
		object LT_EQUAL15_tree = default(object);
		object GT_EQUAL16_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "comp_expr");
		DebugLocation(109, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:2: ( arith_expr ( ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:4: arith_expr ( ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(110, 4);
			PushFollow(Follow._arith_expr_in_comp_expr679);
			arith_expr10=arith_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, arith_expr10.Tree);
			DebugLocation(110, 14);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:14: ( ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				switch (input.LA(1))
				{
				case EQUAL:
					{
					alt4 = 1;
					}
					break;
				case NON_EQUAL:
					{
					alt4 = 1;
					}
					break;
				case LT:
					{
					alt4 = 1;
					}
					break;
				case GT:
					{
					alt4 = 1;
					}
					break;
				case LT_EQUAL:
					{
					alt4 = 1;
					}
					break;
				case GT_EQUAL:
					{
					alt4 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:15: ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^) arith_expr
					{
					DebugLocation(110, 15);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:15: ( EQUAL ^| NON_EQUAL ^| LT ^| GT ^| LT_EQUAL ^| GT_EQUAL ^)
					int alt3=6;
					try { DebugEnterSubRule(3);
					try { DebugEnterDecision(3, false);
					switch (input.LA(1))
					{
					case EQUAL:
						{
						alt3 = 1;
						}
						break;
					case NON_EQUAL:
						{
						alt3 = 2;
						}
						break;
					case LT:
						{
						alt3 = 3;
						}
						break;
					case GT:
						{
						alt3 = 4;
						}
						break;
					case LT_EQUAL:
						{
						alt3 = 5;
						}
						break;
					case GT_EQUAL:
						{
						alt3 = 6;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:16: EQUAL ^
						{
						DebugLocation(110, 21);
						EQUAL11=(IToken)Match(input,EQUAL,Follow._EQUAL_in_comp_expr682); if (state.failed) return retval;
						if (state.backtracking == 0) {
						EQUAL11_tree = (object)adaptor.Create(EQUAL11);
						root_0 = (object)adaptor.BecomeRoot(EQUAL11_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:25: NON_EQUAL ^
						{
						DebugLocation(110, 34);
						NON_EQUAL12=(IToken)Match(input,NON_EQUAL,Follow._NON_EQUAL_in_comp_expr687); if (state.failed) return retval;
						if (state.backtracking == 0) {
						NON_EQUAL12_tree = (object)adaptor.Create(NON_EQUAL12);
						root_0 = (object)adaptor.BecomeRoot(NON_EQUAL12_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:38: LT ^
						{
						DebugLocation(110, 40);
						LT13=(IToken)Match(input,LT,Follow._LT_in_comp_expr692); if (state.failed) return retval;
						if (state.backtracking == 0) {
						LT13_tree = (object)adaptor.Create(LT13);
						root_0 = (object)adaptor.BecomeRoot(LT13_tree, root_0);
						}

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:44: GT ^
						{
						DebugLocation(110, 46);
						GT14=(IToken)Match(input,GT,Follow._GT_in_comp_expr697); if (state.failed) return retval;
						if (state.backtracking == 0) {
						GT14_tree = (object)adaptor.Create(GT14);
						root_0 = (object)adaptor.BecomeRoot(GT14_tree, root_0);
						}

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:50: LT_EQUAL ^
						{
						DebugLocation(110, 58);
						LT_EQUAL15=(IToken)Match(input,LT_EQUAL,Follow._LT_EQUAL_in_comp_expr702); if (state.failed) return retval;
						if (state.backtracking == 0) {
						LT_EQUAL15_tree = (object)adaptor.Create(LT_EQUAL15);
						root_0 = (object)adaptor.BecomeRoot(LT_EQUAL15_tree, root_0);
						}

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:110:62: GT_EQUAL ^
						{
						DebugLocation(110, 70);
						GT_EQUAL16=(IToken)Match(input,GT_EQUAL,Follow._GT_EQUAL_in_comp_expr707); if (state.failed) return retval;
						if (state.backtracking == 0) {
						GT_EQUAL16_tree = (object)adaptor.Create(GT_EQUAL16);
						root_0 = (object)adaptor.BecomeRoot(GT_EQUAL16_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(3); }

					DebugLocation(110, 73);
					PushFollow(Follow._arith_expr_in_comp_expr711);
					arith_expr17=arith_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, arith_expr17.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("comp_expr", 5);
			LeaveRule("comp_expr", 5);
			LeaveRule_comp_expr();
		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "comp_expr"); }
		return retval;

	}
	// $ANTLR end "comp_expr"

	partial void EnterRule_arith_expr();
	partial void LeaveRule_arith_expr();

	// $ANTLR start "arith_expr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:113:1: arith_expr : term ( ( PLUS ^| MINUS ^) term )* ;
	[GrammarRule("arith_expr")]
	private AstParserRuleReturnScope<object, IToken> arith_expr()
	{
		EnterRule_arith_expr();
		EnterRule("arith_expr", 6);
		TraceIn("arith_expr", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS19 = default(IToken);
		IToken MINUS20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term21 = default(AstParserRuleReturnScope<object, IToken>);

		object PLUS19_tree = default(object);
		object MINUS20_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "arith_expr");
		DebugLocation(113, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:114:2: ( term ( ( PLUS ^| MINUS ^) term )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:114:4: term ( ( PLUS ^| MINUS ^) term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(114, 4);
			PushFollow(Follow._term_in_arith_expr724);
			term18=term();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, term18.Tree);
			DebugLocation(114, 8);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:114:8: ( ( PLUS ^| MINUS ^) term )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==PLUS))
				{
					alt6 = 1;
				}
				else if ((LA6_0==MINUS))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:114:9: ( PLUS ^| MINUS ^) term
					{
					DebugLocation(114, 9);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:114:9: ( PLUS ^| MINUS ^)
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==PLUS))
					{
						alt5 = 1;
					}
					else if ((LA5_0==MINUS))
					{
						alt5 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:114:10: PLUS ^
						{
						DebugLocation(114, 14);
						PLUS19=(IToken)Match(input,PLUS,Follow._PLUS_in_arith_expr727); if (state.failed) return retval;
						if (state.backtracking == 0) {
						PLUS19_tree = (object)adaptor.Create(PLUS19);
						root_0 = (object)adaptor.BecomeRoot(PLUS19_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:114:16: MINUS ^
						{
						DebugLocation(114, 21);
						MINUS20=(IToken)Match(input,MINUS,Follow._MINUS_in_arith_expr730); if (state.failed) return retval;
						if (state.backtracking == 0) {
						MINUS20_tree = (object)adaptor.Create(MINUS20);
						root_0 = (object)adaptor.BecomeRoot(MINUS20_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(5); }

					DebugLocation(114, 24);
					PushFollow(Follow._term_in_arith_expr734);
					term21=term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, term21.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arith_expr", 6);
			LeaveRule("arith_expr", 6);
			LeaveRule_arith_expr();
		}
		DebugLocation(115, 1);
		} finally { DebugExitRule(GrammarFileName, "arith_expr"); }
		return retval;

	}
	// $ANTLR end "arith_expr"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:1: term : texpr ( ( MUL ^| DIV ^) texpr )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 7);
		TraceIn("term", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MUL23 = default(IToken);
		IToken DIV24 = default(IToken);
		AstParserRuleReturnScope<object, IToken> texpr22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> texpr25 = default(AstParserRuleReturnScope<object, IToken>);

		object MUL23_tree = default(object);
		object DIV24_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(117, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:6: ( texpr ( ( MUL ^| DIV ^) texpr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:8: texpr ( ( MUL ^| DIV ^) texpr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(117, 8);
			PushFollow(Follow._texpr_in_term746);
			texpr22=texpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, texpr22.Tree);
			DebugLocation(117, 13);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:13: ( ( MUL ^| DIV ^) texpr )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==MUL))
				{
					alt8 = 1;
				}
				else if ((LA8_0==DIV))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:14: ( MUL ^| DIV ^) texpr
					{
					DebugLocation(117, 14);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:14: ( MUL ^| DIV ^)
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==MUL))
					{
						alt7 = 1;
					}
					else if ((LA7_0==DIV))
					{
						alt7 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:15: MUL ^
						{
						DebugLocation(117, 18);
						MUL23=(IToken)Match(input,MUL,Follow._MUL_in_term749); if (state.failed) return retval;
						if (state.backtracking == 0) {
						MUL23_tree = (object)adaptor.Create(MUL23);
						root_0 = (object)adaptor.BecomeRoot(MUL23_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:117:20: DIV ^
						{
						DebugLocation(117, 23);
						DIV24=(IToken)Match(input,DIV,Follow._DIV_in_term752); if (state.failed) return retval;
						if (state.backtracking == 0) {
						DIV24_tree = (object)adaptor.Create(DIV24);
						root_0 = (object)adaptor.BecomeRoot(DIV24_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(117, 26);
					PushFollow(Follow._texpr_in_term756);
					texpr25=texpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, texpr25.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 7);
			LeaveRule("term", 7);
			LeaveRule_term();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_texpr();
	partial void LeaveRule_texpr();

	// $ANTLR start "texpr"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:1: texpr : ( STRING | INT | NIL | ( ID '[' expr ']' 'of' )=> type_id '[' e1= expr ']' 'of' e2= expr -> ^( ARRAY_CREATION type_id $e1 $e2) | ( ID '(' )=> ( ID '(' ( expr_list )? ')' ) -> ^( FUNCTION_CALL ID ^( EXPRESSION_LIST ( expr_list )? ) ) | ( ID '{' )=> ( ID '{' ( field_list )? '}' ) -> ^( RECORD_CREATION ID ( field_list )? ) | ( lvalue ASSIGN )=> ( lvalue ASSIGN expr ) -> ^( ASSIGN lvalue expr ) | lvalue | '(' ( expr_seq )? ')' -> ^( EXPRESSION_SEQ ( expr_seq )? ) | ( 'if' expr 'then' expr 'else' )=> ( 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr ) -> ^( IF_THEN_ELSE $ifx $thenx $elsex) | 'if' ifx= expr 'then' elsex= expr -> ^( IF_THEN $ifx $elsex) | WHILE condition= expr 'do' something= expr -> ^( WHILE $condition $something) | FOR var= ID ASSIGN init= expr 'to' limit= expr 'do' something= expr -> ^( FOR $var $init $limit $something) | BREAK | LET declaration_list 'in' ( expr_seq )? 'end' -> ^( LET declaration_list ( expr_seq )? ) | MINUS texpr -> ^( UMINUS texpr ) );
	[GrammarRule("texpr")]
	private AstParserRuleReturnScope<object, IToken> texpr()
	{
		EnterRule_texpr();
		EnterRule("texpr", 8);
		TraceIn("texpr", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken var = default(IToken);
		IToken STRING26 = default(IToken);
		IToken INT27 = default(IToken);
		IToken NIL28 = default(IToken);
		IToken char_literal30 = default(IToken);
		IToken char_literal31 = default(IToken);
		IToken string_literal32 = default(IToken);
		IToken ID33 = default(IToken);
		IToken char_literal34 = default(IToken);
		IToken char_literal36 = default(IToken);
		IToken ID37 = default(IToken);
		IToken char_literal38 = default(IToken);
		IToken char_literal40 = default(IToken);
		IToken ASSIGN42 = default(IToken);
		IToken char_literal45 = default(IToken);
		IToken char_literal47 = default(IToken);
		IToken string_literal48 = default(IToken);
		IToken string_literal49 = default(IToken);
		IToken string_literal50 = default(IToken);
		IToken string_literal51 = default(IToken);
		IToken string_literal52 = default(IToken);
		IToken WHILE53 = default(IToken);
		IToken string_literal54 = default(IToken);
		IToken FOR55 = default(IToken);
		IToken ASSIGN56 = default(IToken);
		IToken string_literal57 = default(IToken);
		IToken string_literal58 = default(IToken);
		IToken BREAK59 = default(IToken);
		IToken LET60 = default(IToken);
		IToken string_literal62 = default(IToken);
		IToken string_literal64 = default(IToken);
		IToken MINUS65 = default(IToken);
		AstParserRuleReturnScope<object, IToken> e1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> e2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ifx = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> thenx = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> elsex = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> condition = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> something = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> init = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> limit = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id29 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_list35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> field_list39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue44 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> declaration_list61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq63 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> texpr66 = default(AstParserRuleReturnScope<object, IToken>);

		object var_tree = default(object);
		object STRING26_tree = default(object);
		object INT27_tree = default(object);
		object NIL28_tree = default(object);
		object char_literal30_tree = default(object);
		object char_literal31_tree = default(object);
		object string_literal32_tree = default(object);
		object ID33_tree = default(object);
		object char_literal34_tree = default(object);
		object char_literal36_tree = default(object);
		object ID37_tree = default(object);
		object char_literal38_tree = default(object);
		object char_literal40_tree = default(object);
		object ASSIGN42_tree = default(object);
		object char_literal45_tree = default(object);
		object char_literal47_tree = default(object);
		object string_literal48_tree = default(object);
		object string_literal49_tree = default(object);
		object string_literal50_tree = default(object);
		object string_literal51_tree = default(object);
		object string_literal52_tree = default(object);
		object WHILE53_tree = default(object);
		object string_literal54_tree = default(object);
		object FOR55_tree = default(object);
		object ASSIGN56_tree = default(object);
		object string_literal57_tree = default(object);
		object string_literal58_tree = default(object);
		object BREAK59_tree = default(object);
		object LET60_tree = default(object);
		object string_literal62_tree = default(object);
		object string_literal64_tree = default(object);
		object MINUS65_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_LET=new RewriteRuleITokenStream(adaptor,"token LET");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleSubtreeStream stream_declaration_list=new RewriteRuleSubtreeStream(adaptor,"rule declaration_list");
		RewriteRuleSubtreeStream stream_lvalue=new RewriteRuleSubtreeStream(adaptor,"rule lvalue");
		RewriteRuleSubtreeStream stream_field_list=new RewriteRuleSubtreeStream(adaptor,"rule field_list");
		RewriteRuleSubtreeStream stream_texpr=new RewriteRuleSubtreeStream(adaptor,"rule texpr");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_expr_seq=new RewriteRuleSubtreeStream(adaptor,"rule expr_seq");
		RewriteRuleSubtreeStream stream_expr_list=new RewriteRuleSubtreeStream(adaptor,"rule expr_list");
		try { DebugEnterRule(GrammarFileName, "texpr");
		DebugLocation(120, 2);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:6: ( STRING | INT | NIL | ( ID '[' expr ']' 'of' )=> type_id '[' e1= expr ']' 'of' e2= expr -> ^( ARRAY_CREATION type_id $e1 $e2) | ( ID '(' )=> ( ID '(' ( expr_list )? ')' ) -> ^( FUNCTION_CALL ID ^( EXPRESSION_LIST ( expr_list )? ) ) | ( ID '{' )=> ( ID '{' ( field_list )? '}' ) -> ^( RECORD_CREATION ID ( field_list )? ) | ( lvalue ASSIGN )=> ( lvalue ASSIGN expr ) -> ^( ASSIGN lvalue expr ) | lvalue | '(' ( expr_seq )? ')' -> ^( EXPRESSION_SEQ ( expr_seq )? ) | ( 'if' expr 'then' expr 'else' )=> ( 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr ) -> ^( IF_THEN_ELSE $ifx $thenx $elsex) | 'if' ifx= expr 'then' elsex= expr -> ^( IF_THEN $ifx $elsex) | WHILE condition= expr 'do' something= expr -> ^( WHILE $condition $something) | FOR var= ID ASSIGN init= expr 'to' limit= expr 'do' something= expr -> ^( FOR $var $init $limit $something) | BREAK | LET declaration_list 'in' ( expr_seq )? 'end' -> ^( LET declaration_list ( expr_seq )? ) | MINUS texpr -> ^( UMINUS texpr ) )
			int alt13=16;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case STRING:
				{
				alt13 = 1;
				}
				break;
			case INT:
				{
				alt13 = 2;
				}
				break;
			case NIL:
				{
				alt13 = 3;
				}
				break;
			case ID:
				{
				int LA13_4 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Tiger_fragment)))
				{
					alt13 = 4;
				}
				else if ((EvaluatePredicate(synpred2_Tiger_fragment)))
				{
					alt13 = 5;
				}
				else if ((EvaluatePredicate(synpred3_Tiger_fragment)))
				{
					alt13 = 6;
				}
				else if ((EvaluatePredicate(synpred4_Tiger_fragment)))
				{
					alt13 = 7;
				}
				else if ((true))
				{
					alt13 = 8;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 4, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 47:
				{
				alt13 = 9;
				}
				break;
			case 60:
				{
				int LA13_6 = input.LA(2);

				if ((EvaluatePredicate(synpred5_Tiger_fragment)))
				{
					alt13 = 10;
				}
				else if ((true))
				{
					alt13 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case WHILE:
				{
				alt13 = 12;
				}
				break;
			case FOR:
				{
				alt13 = 13;
				}
				break;
			case BREAK:
				{
				alt13 = 14;
				}
				break;
			case LET:
				{
				alt13 = 15;
				}
				break;
			case MINUS:
				{
				alt13 = 16;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:120:12: STRING
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(120, 12);
				STRING26=(IToken)Match(input,STRING,Follow._STRING_in_texpr771); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STRING26_tree = (object)adaptor.Create(STRING26);
				adaptor.AddChild(root_0, STRING26_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:121:5: INT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(121, 5);
				INT27=(IToken)Match(input,INT,Follow._INT_in_texpr777); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INT27_tree = (object)adaptor.Create(INT27);
				adaptor.AddChild(root_0, INT27_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:122:5: NIL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(122, 5);
				NIL28=(IToken)Match(input,NIL,Follow._NIL_in_texpr783); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NIL28_tree = (object)adaptor.Create(NIL28);
				adaptor.AddChild(root_0, NIL28_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:123:5: ( ID '[' expr ']' 'of' )=> type_id '[' e1= expr ']' 'of' e2= expr
				{
				DebugLocation(123, 31);
				PushFollow(Follow._type_id_in_texpr803);
				type_id29=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id29.Tree);
				DebugLocation(123, 39);
				char_literal30=(IToken)Match(input,53,Follow._53_in_texpr805); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(char_literal30);

				DebugLocation(123, 45);
				PushFollow(Follow._expr_in_texpr809);
				e1=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(e1.Tree);
				DebugLocation(123, 51);
				char_literal31=(IToken)Match(input,54,Follow._54_in_texpr811); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_54.Add(char_literal31);

				DebugLocation(123, 55);
				string_literal32=(IToken)Match(input,62,Follow._62_in_texpr813); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(string_literal32);

				DebugLocation(123, 62);
				PushFollow(Follow._expr_in_texpr817);
				e2=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(e2.Tree);


				{
				// AST REWRITE
				// elements: e1, e2, type_id
				// token labels: 
				// rule labels: retval, e1, e2
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.Tree:null);
				RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 123:68: -> ^( ARRAY_CREATION type_id $e1 $e2)
				{
					DebugLocation(123, 71);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:123:71: ^( ARRAY_CREATION type_id $e1 $e2)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(123, 73);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_CREATION, "ARRAY_CREATION"), root_1);

					DebugLocation(123, 88);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(123, 97);
					adaptor.AddChild(root_1, stream_e1.NextTree());
					DebugLocation(123, 101);
					adaptor.AddChild(root_1, stream_e2.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:5: ( ID '(' )=> ( ID '(' ( expr_list )? ')' )
				{
				DebugLocation(124, 15);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:15: ( ID '(' ( expr_list )? ')' )
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:16: ID '(' ( expr_list )? ')'
				{
				DebugLocation(124, 16);
				ID33=(IToken)Match(input,ID,Follow._ID_in_texpr845); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID33);

				DebugLocation(124, 19);
				char_literal34=(IToken)Match(input,47,Follow._47_in_texpr847); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_47.Add(char_literal34);

				DebugLocation(124, 23);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:23: ( expr_list )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==BREAK||LA9_0==FOR||LA9_0==ID||(LA9_0>=INT && LA9_0<=LET)||LA9_0==MINUS||LA9_0==NIL||LA9_0==STRING||LA9_0==WHILE||LA9_0==47||LA9_0==60))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:23: expr_list
					{
					DebugLocation(124, 23);
					PushFollow(Follow._expr_list_in_texpr849);
					expr_list35=expr_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_list.Add(expr_list35.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(124, 34);
				char_literal36=(IToken)Match(input,48,Follow._48_in_texpr852); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_48.Add(char_literal36);


				}



				{
				// AST REWRITE
				// elements: expr_list, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 124:39: -> ^( FUNCTION_CALL ID ^( EXPRESSION_LIST ( expr_list )? ) )
				{
					DebugLocation(124, 42);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:42: ^( FUNCTION_CALL ID ^( EXPRESSION_LIST ( expr_list )? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(124, 44);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_CALL, "FUNCTION_CALL"), root_1);

					DebugLocation(124, 58);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(124, 61);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:61: ^( EXPRESSION_LIST ( expr_list )? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(124, 63);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSION_LIST, "EXPRESSION_LIST"), root_2);

					DebugLocation(124, 79);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:79: ( expr_list )?
					if (stream_expr_list.HasNext)
					{
						DebugLocation(124, 79);
						adaptor.AddChild(root_2, stream_expr_list.NextTree());

					}
					stream_expr_list.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:5: ( ID '{' )=> ( ID '{' ( field_list )? '}' )
				{
				DebugLocation(125, 17);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:17: ( ID '{' ( field_list )? '}' )
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:18: ID '{' ( field_list )? '}'
				{
				DebugLocation(125, 18);
				ID37=(IToken)Match(input,ID,Follow._ID_in_texpr883); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID37);

				DebugLocation(125, 21);
				char_literal38=(IToken)Match(input,67,Follow._67_in_texpr885); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_67.Add(char_literal38);

				DebugLocation(125, 25);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:25: ( field_list )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==ID))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:25: field_list
					{
					DebugLocation(125, 25);
					PushFollow(Follow._field_list_in_texpr887);
					field_list39=field_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_field_list.Add(field_list39.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(125, 37);
				char_literal40=(IToken)Match(input,68,Follow._68_in_texpr890); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_68.Add(char_literal40);


				}



				{
				// AST REWRITE
				// elements: field_list, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 125:42: -> ^( RECORD_CREATION ID ( field_list )? )
				{
					DebugLocation(125, 45);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:45: ^( RECORD_CREATION ID ( field_list )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(125, 47);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_CREATION, "RECORD_CREATION"), root_1);

					DebugLocation(125, 63);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(125, 66);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:66: ( field_list )?
					if (stream_field_list.HasNext)
					{
						DebugLocation(125, 66);
						adaptor.AddChild(root_1, stream_field_list.NextTree());

					}
					stream_field_list.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:5: ( lvalue ASSIGN )=> ( lvalue ASSIGN expr )
				{
				DebugLocation(126, 24);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:24: ( lvalue ASSIGN expr )
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:25: lvalue ASSIGN expr
				{
				DebugLocation(126, 25);
				PushFollow(Follow._lvalue_in_texpr917);
				lvalue41=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_lvalue.Add(lvalue41.Tree);
				DebugLocation(126, 32);
				ASSIGN42=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_texpr919); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN42);

				DebugLocation(126, 39);
				PushFollow(Follow._expr_in_texpr921);
				expr43=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr43.Tree);

				}



				{
				// AST REWRITE
				// elements: expr, lvalue, ASSIGN
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 126:45: -> ^( ASSIGN lvalue expr )
				{
					DebugLocation(126, 48);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:48: ^( ASSIGN lvalue expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(126, 50);
					root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

					DebugLocation(126, 57);
					adaptor.AddChild(root_1, stream_lvalue.NextTree());
					DebugLocation(126, 64);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:127:5: lvalue
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(127, 5);
				PushFollow(Follow._lvalue_in_texpr938);
				lvalue44=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, lvalue44.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:5: '(' ( expr_seq )? ')'
				{
				DebugLocation(128, 5);
				char_literal45=(IToken)Match(input,47,Follow._47_in_texpr944); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_47.Add(char_literal45);

				DebugLocation(128, 9);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:9: ( expr_seq )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==BREAK||LA11_0==FOR||LA11_0==ID||(LA11_0>=INT && LA11_0<=LET)||LA11_0==MINUS||LA11_0==NIL||LA11_0==STRING||LA11_0==WHILE||LA11_0==47||LA11_0==60))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:9: expr_seq
					{
					DebugLocation(128, 9);
					PushFollow(Follow._expr_seq_in_texpr946);
					expr_seq46=expr_seq();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_seq.Add(expr_seq46.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(128, 19);
				char_literal47=(IToken)Match(input,48,Follow._48_in_texpr949); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_48.Add(char_literal47);



				{
				// AST REWRITE
				// elements: expr_seq
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 128:23: -> ^( EXPRESSION_SEQ ( expr_seq )? )
				{
					DebugLocation(128, 26);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:26: ^( EXPRESSION_SEQ ( expr_seq )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(128, 28);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSION_SEQ, "EXPRESSION_SEQ"), root_1);

					DebugLocation(128, 43);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:128:43: ( expr_seq )?
					if (stream_expr_seq.HasNext)
					{
						DebugLocation(128, 43);
						adaptor.AddChild(root_1, stream_expr_seq.NextTree());

					}
					stream_expr_seq.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:5: ( 'if' expr 'then' expr 'else' )=> ( 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr )
				{
				DebugLocation(129, 39);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:39: ( 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr )
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:40: 'if' ifx= expr 'then' thenx= expr 'else' elsex= expr
				{
				DebugLocation(129, 40);
				string_literal48=(IToken)Match(input,60,Follow._60_in_texpr979); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_60.Add(string_literal48);

				DebugLocation(129, 48);
				PushFollow(Follow._expr_in_texpr983);
				ifx=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(ifx.Tree);
				DebugLocation(129, 54);
				string_literal49=(IToken)Match(input,63,Follow._63_in_texpr985); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal49);

				DebugLocation(129, 66);
				PushFollow(Follow._expr_in_texpr989);
				thenx=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(thenx.Tree);
				DebugLocation(129, 72);
				string_literal50=(IToken)Match(input,57,Follow._57_in_texpr991); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(string_literal50);

				DebugLocation(129, 84);
				PushFollow(Follow._expr_in_texpr995);
				elsex=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(elsex.Tree);

				}



				{
				// AST REWRITE
				// elements: ifx, thenx, elsex
				// token labels: 
				// rule labels: ifx, retval, thenx, elsex
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ifx=new RewriteRuleSubtreeStream(adaptor,"rule ifx",ifx!=null?ifx.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_thenx=new RewriteRuleSubtreeStream(adaptor,"rule thenx",thenx!=null?thenx.Tree:null);
				RewriteRuleSubtreeStream stream_elsex=new RewriteRuleSubtreeStream(adaptor,"rule elsex",elsex!=null?elsex.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 129:91: -> ^( IF_THEN_ELSE $ifx $thenx $elsex)
				{
					DebugLocation(129, 94);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:94: ^( IF_THEN_ELSE $ifx $thenx $elsex)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(129, 96);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF_THEN_ELSE, "IF_THEN_ELSE"), root_1);

					DebugLocation(129, 110);
					adaptor.AddChild(root_1, stream_ifx.NextTree());
					DebugLocation(129, 115);
					adaptor.AddChild(root_1, stream_thenx.NextTree());
					DebugLocation(129, 122);
					adaptor.AddChild(root_1, stream_elsex.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:130:5: 'if' ifx= expr 'then' elsex= expr
				{
				DebugLocation(130, 5);
				string_literal51=(IToken)Match(input,60,Follow._60_in_texpr1017); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_60.Add(string_literal51);

				DebugLocation(130, 13);
				PushFollow(Follow._expr_in_texpr1021);
				ifx=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(ifx.Tree);
				DebugLocation(130, 19);
				string_literal52=(IToken)Match(input,63,Follow._63_in_texpr1023); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal52);

				DebugLocation(130, 31);
				PushFollow(Follow._expr_in_texpr1027);
				elsex=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(elsex.Tree);


				{
				// AST REWRITE
				// elements: ifx, elsex
				// token labels: 
				// rule labels: ifx, retval, elsex
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ifx=new RewriteRuleSubtreeStream(adaptor,"rule ifx",ifx!=null?ifx.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_elsex=new RewriteRuleSubtreeStream(adaptor,"rule elsex",elsex!=null?elsex.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 130:37: -> ^( IF_THEN $ifx $elsex)
				{
					DebugLocation(130, 40);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:130:40: ^( IF_THEN $ifx $elsex)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(130, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF_THEN, "IF_THEN"), root_1);

					DebugLocation(130, 51);
					adaptor.AddChild(root_1, stream_ifx.NextTree());
					DebugLocation(130, 56);
					adaptor.AddChild(root_1, stream_elsex.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:131:5: WHILE condition= expr 'do' something= expr
				{
				DebugLocation(131, 5);
				WHILE53=(IToken)Match(input,WHILE,Follow._WHILE_in_texpr1045); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WHILE.Add(WHILE53);

				DebugLocation(131, 20);
				PushFollow(Follow._expr_in_texpr1049);
				condition=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(condition.Tree);
				DebugLocation(131, 26);
				string_literal54=(IToken)Match(input,56,Follow._56_in_texpr1051); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(string_literal54);

				DebugLocation(131, 40);
				PushFollow(Follow._expr_in_texpr1055);
				something=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(something.Tree);


				{
				// AST REWRITE
				// elements: something, WHILE, condition
				// token labels: 
				// rule labels: retval, condition, something
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition",condition!=null?condition.Tree:null);
				RewriteRuleSubtreeStream stream_something=new RewriteRuleSubtreeStream(adaptor,"rule something",something!=null?something.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 131:46: -> ^( WHILE $condition $something)
				{
					DebugLocation(131, 49);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:131:49: ^( WHILE $condition $something)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(131, 51);
					root_1 = (object)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

					DebugLocation(131, 58);
					adaptor.AddChild(root_1, stream_condition.NextTree());
					DebugLocation(131, 69);
					adaptor.AddChild(root_1, stream_something.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:132:5: FOR var= ID ASSIGN init= expr 'to' limit= expr 'do' something= expr
				{
				DebugLocation(132, 5);
				FOR55=(IToken)Match(input,FOR,Follow._FOR_in_texpr1073); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FOR.Add(FOR55);

				DebugLocation(132, 12);
				var=(IToken)Match(input,ID,Follow._ID_in_texpr1077); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(var);

				DebugLocation(132, 16);
				ASSIGN56=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_texpr1079); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN56);

				DebugLocation(132, 27);
				PushFollow(Follow._expr_in_texpr1083);
				init=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(init.Tree);
				DebugLocation(132, 33);
				string_literal57=(IToken)Match(input,64,Follow._64_in_texpr1085); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal57);

				DebugLocation(132, 43);
				PushFollow(Follow._expr_in_texpr1089);
				limit=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(limit.Tree);
				DebugLocation(132, 49);
				string_literal58=(IToken)Match(input,56,Follow._56_in_texpr1091); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(string_literal58);

				DebugLocation(132, 63);
				PushFollow(Follow._expr_in_texpr1095);
				something=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(something.Tree);


				{
				// AST REWRITE
				// elements: var, something, init, limit, FOR
				// token labels: var
				// rule labels: limit, retval, init, something
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_var=new RewriteRuleITokenStream(adaptor,"token var",var);
				RewriteRuleSubtreeStream stream_limit=new RewriteRuleSubtreeStream(adaptor,"rule limit",limit!=null?limit.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_init=new RewriteRuleSubtreeStream(adaptor,"rule init",init!=null?init.Tree:null);
				RewriteRuleSubtreeStream stream_something=new RewriteRuleSubtreeStream(adaptor,"rule something",something!=null?something.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 132:69: -> ^( FOR $var $init $limit $something)
				{
					DebugLocation(132, 72);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:132:72: ^( FOR $var $init $limit $something)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(132, 74);
					root_1 = (object)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

					DebugLocation(132, 79);
					adaptor.AddChild(root_1, stream_var.NextNode());
					DebugLocation(132, 84);
					adaptor.AddChild(root_1, stream_init.NextTree());
					DebugLocation(132, 90);
					adaptor.AddChild(root_1, stream_limit.NextTree());
					DebugLocation(132, 97);
					adaptor.AddChild(root_1, stream_something.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:133:5: BREAK
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(133, 5);
				BREAK59=(IToken)Match(input,BREAK,Follow._BREAK_in_texpr1119); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BREAK59_tree = (object)adaptor.Create(BREAK59);
				adaptor.AddChild(root_0, BREAK59_tree);
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:134:5: LET declaration_list 'in' ( expr_seq )? 'end'
				{
				DebugLocation(134, 5);
				LET60=(IToken)Match(input,LET,Follow._LET_in_texpr1125); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LET.Add(LET60);

				DebugLocation(134, 9);
				PushFollow(Follow._declaration_list_in_texpr1127);
				declaration_list61=declaration_list();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_declaration_list.Add(declaration_list61.Tree);
				DebugLocation(134, 26);
				string_literal62=(IToken)Match(input,61,Follow._61_in_texpr1129); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_61.Add(string_literal62);

				DebugLocation(134, 31);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:134:31: ( expr_seq )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==BREAK||LA12_0==FOR||LA12_0==ID||(LA12_0>=INT && LA12_0<=LET)||LA12_0==MINUS||LA12_0==NIL||LA12_0==STRING||LA12_0==WHILE||LA12_0==47||LA12_0==60))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:134:31: expr_seq
					{
					DebugLocation(134, 31);
					PushFollow(Follow._expr_seq_in_texpr1131);
					expr_seq63=expr_seq();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr_seq.Add(expr_seq63.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(134, 41);
				string_literal64=(IToken)Match(input,58,Follow._58_in_texpr1134); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_58.Add(string_literal64);



				{
				// AST REWRITE
				// elements: declaration_list, expr_seq, LET
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 134:47: -> ^( LET declaration_list ( expr_seq )? )
				{
					DebugLocation(134, 50);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:134:50: ^( LET declaration_list ( expr_seq )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(134, 52);
					root_1 = (object)adaptor.BecomeRoot(stream_LET.NextNode(), root_1);

					DebugLocation(134, 56);
					adaptor.AddChild(root_1, stream_declaration_list.NextTree());
					DebugLocation(134, 73);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:134:73: ( expr_seq )?
					if (stream_expr_seq.HasNext)
					{
						DebugLocation(134, 73);
						adaptor.AddChild(root_1, stream_expr_seq.NextTree());

					}
					stream_expr_seq.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:135:5: MINUS texpr
				{
				DebugLocation(135, 5);
				MINUS65=(IToken)Match(input,MINUS,Follow._MINUS_in_texpr1151); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS65);

				DebugLocation(135, 11);
				PushFollow(Follow._texpr_in_texpr1153);
				texpr66=texpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_texpr.Add(texpr66.Tree);


				{
				// AST REWRITE
				// elements: texpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 135:17: -> ^( UMINUS texpr )
				{
					DebugLocation(135, 20);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:135:20: ^( UMINUS texpr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(135, 22);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(UMINUS, "UMINUS"), root_1);

					DebugLocation(135, 29);
					adaptor.AddChild(root_1, stream_texpr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("texpr", 8);
			LeaveRule("texpr", 8);
			LeaveRule_texpr();
		}
		DebugLocation(136, 2);
		} finally { DebugExitRule(GrammarFileName, "texpr"); }
		return retval;

	}
	// $ANTLR end "texpr"

	partial void EnterRule_type_id();
	partial void LeaveRule_type_id();

	// $ANTLR start "type_id"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:139:1: type_id : ID -> ^( TYPE_ID ID ) ;
	[GrammarRule("type_id")]
	private AstParserRuleReturnScope<object, IToken> type_id()
	{
		EnterRule_type_id();
		EnterRule("type_id", 9);
		TraceIn("type_id", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID67 = default(IToken);

		object ID67_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "type_id");
		DebugLocation(139, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:139:9: ( ID -> ^( TYPE_ID ID ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:139:12: ID
			{
			DebugLocation(139, 12);
			ID67=(IToken)Match(input,ID,Follow._ID_in_type_id1174); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID67);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 139:15: -> ^( TYPE_ID ID )
			{
				DebugLocation(139, 18);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:139:18: ^( TYPE_ID ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(139, 20);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_ID, "TYPE_ID"), root_1);

				DebugLocation(139, 28);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_id", 9);
			LeaveRule("type_id", 9);
			LeaveRule_type_id();
		}
		DebugLocation(140, 1);
		} finally { DebugExitRule(GrammarFileName, "type_id"); }
		return retval;

	}
	// $ANTLR end "type_id"

	partial void EnterRule_type_declaration();
	partial void LeaveRule_type_declaration();

	// $ANTLR start "type_declaration"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:142:1: type_declaration : 'type' type_id EQUAL type -> ^( TYPE_DECL type_id type ) ;
	[GrammarRule("type_declaration")]
	private AstParserRuleReturnScope<object, IToken> type_declaration()
	{
		EnterRule_type_declaration();
		EnterRule("type_declaration", 10);
		TraceIn("type_declaration", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal68 = default(IToken);
		IToken EQUAL70 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id69 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type71 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal68_tree = default(object);
		object EQUAL70_tree = default(object);
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type_declaration");
		DebugLocation(142, 56);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:142:17: ( 'type' type_id EQUAL type -> ^( TYPE_DECL type_id type ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:143:3: 'type' type_id EQUAL type
			{
			DebugLocation(143, 3);
			string_literal68=(IToken)Match(input,65,Follow._65_in_type_declaration1194); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_65.Add(string_literal68);

			DebugLocation(143, 10);
			PushFollow(Follow._type_id_in_type_declaration1196);
			type_id69=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id69.Tree);
			DebugLocation(143, 18);
			EQUAL70=(IToken)Match(input,EQUAL,Follow._EQUAL_in_type_declaration1198); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQUAL.Add(EQUAL70);

			DebugLocation(143, 24);
			PushFollow(Follow._type_in_type_declaration1200);
			type71=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type71.Tree);


			{
			// AST REWRITE
			// elements: type, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 143:29: -> ^( TYPE_DECL type_id type )
			{
				DebugLocation(143, 32);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:143:32: ^( TYPE_DECL type_id type )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(143, 34);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_DECL, "TYPE_DECL"), root_1);

				DebugLocation(143, 44);
				adaptor.AddChild(root_1, stream_type_id.NextTree());
				DebugLocation(143, 52);
				adaptor.AddChild(root_1, stream_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_declaration", 10);
			LeaveRule("type_declaration", 10);
			LeaveRule_type_declaration();
		}
		DebugLocation(143, 56);
		} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
		return retval;

	}
	// $ANTLR end "type_declaration"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:145:1: type : ( type_id -> ALIAS_DECL | '{' type_fields '}' -> ^( RECORD_DECL type_fields ) | 'array' 'of' type_id -> ^( ARRAY_TYPE_DECL type_id ) );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 11);
		TraceIn("type", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal73 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken string_literal76 = default(IToken);
		IToken string_literal77 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id72 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_fields74 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id78 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal73_tree = default(object);
		object char_literal75_tree = default(object);
		object string_literal76_tree = default(object);
		object string_literal77_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(145, 53);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:145:5: ( type_id -> ALIAS_DECL | '{' type_fields '}' -> ^( RECORD_DECL type_fields ) | 'array' 'of' type_id -> ^( ARRAY_TYPE_DECL type_id ) )
			int alt14=3;
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt14 = 1;
				}
				break;
			case 67:
				{
				alt14 = 2;
				}
				break;
			case 55:
				{
				alt14 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:145:8: type_id
				{
				DebugLocation(145, 8);
				PushFollow(Follow._type_id_in_type1218);
				type_id72=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id72.Tree);


				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 145:16: -> ALIAS_DECL
				{
					DebugLocation(145, 19);
					adaptor.AddChild(root_0, (object)adaptor.Create(ALIAS_DECL, "ALIAS_DECL"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:146:4: '{' type_fields '}'
				{
				DebugLocation(146, 4);
				char_literal73=(IToken)Match(input,67,Follow._67_in_type1227); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_67.Add(char_literal73);

				DebugLocation(146, 8);
				PushFollow(Follow._type_fields_in_type1229);
				type_fields74=type_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_fields.Add(type_fields74.Tree);
				DebugLocation(146, 20);
				char_literal75=(IToken)Match(input,68,Follow._68_in_type1231); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_68.Add(char_literal75);



				{
				// AST REWRITE
				// elements: type_fields
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 146:24: -> ^( RECORD_DECL type_fields )
				{
					DebugLocation(146, 27);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:146:27: ^( RECORD_DECL type_fields )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(146, 29);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_DECL, "RECORD_DECL"), root_1);

					DebugLocation(146, 41);
					adaptor.AddChild(root_1, stream_type_fields.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:147:4: 'array' 'of' type_id
				{
				DebugLocation(147, 4);
				string_literal76=(IToken)Match(input,55,Follow._55_in_type1244); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_55.Add(string_literal76);

				DebugLocation(147, 12);
				string_literal77=(IToken)Match(input,62,Follow._62_in_type1246); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(string_literal77);

				DebugLocation(147, 17);
				PushFollow(Follow._type_id_in_type1248);
				type_id78=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id78.Tree);


				{
				// AST REWRITE
				// elements: type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 147:25: -> ^( ARRAY_TYPE_DECL type_id )
				{
					DebugLocation(147, 28);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:147:28: ^( ARRAY_TYPE_DECL type_id )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(147, 30);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_TYPE_DECL, "ARRAY_TYPE_DECL"), root_1);

					DebugLocation(147, 46);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 11);
			LeaveRule("type", 11);
			LeaveRule_type();
		}
		DebugLocation(147, 53);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_type_fields();
	partial void LeaveRule_type_fields();

	// $ANTLR start "type_fields"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:149:1: type_fields : type_field ( ',' type_field )* ;
	[GrammarRule("type_fields")]
	private AstParserRuleReturnScope<object, IToken> type_fields()
	{
		EnterRule_type_fields();
		EnterRule("type_fields", 12);
		TraceIn("type_fields", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal80 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_field79 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_field81 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal80_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_fields");
		DebugLocation(149, 30);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:149:12: ( type_field ( ',' type_field )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:150:3: type_field ( ',' type_field )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(150, 3);
			PushFollow(Follow._type_field_in_type_fields1266);
			type_field79=type_field();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, type_field79.Tree);
			DebugLocation(150, 14);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:150:14: ( ',' type_field )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==49))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:150:15: ',' type_field
					{
					DebugLocation(150, 15);
					char_literal80=(IToken)Match(input,49,Follow._49_in_type_fields1269); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal80_tree = (object)adaptor.Create(char_literal80);
					adaptor.AddChild(root_0, char_literal80_tree);
					}
					DebugLocation(150, 19);
					PushFollow(Follow._type_field_in_type_fields1271);
					type_field81=type_field();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, type_field81.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_fields", 12);
			LeaveRule("type_fields", 12);
			LeaveRule_type_fields();
		}
		DebugLocation(150, 30);
		} finally { DebugExitRule(GrammarFileName, "type_fields"); }
		return retval;

	}
	// $ANTLR end "type_fields"

	partial void EnterRule_type_field();
	partial void LeaveRule_type_field();

	// $ANTLR start "type_field"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:152:1: type_field : ID ':' type_id ;
	[GrammarRule("type_field")]
	private AstParserRuleReturnScope<object, IToken> type_field()
	{
		EnterRule_type_field();
		EnterRule("type_field", 13);
		TraceIn("type_field", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID82 = default(IToken);
		IToken char_literal83 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id84 = default(AstParserRuleReturnScope<object, IToken>);

		object ID82_tree = default(object);
		object char_literal83_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_field");
		DebugLocation(152, 16);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:152:11: ( ID ':' type_id )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:153:3: ID ':' type_id
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(153, 3);
			ID82=(IToken)Match(input,ID,Follow._ID_in_type_field1283); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID82_tree = (object)adaptor.Create(ID82);
			adaptor.AddChild(root_0, ID82_tree);
			}
			DebugLocation(153, 6);
			char_literal83=(IToken)Match(input,51,Follow._51_in_type_field1285); if (state.failed) return retval;
			if (state.backtracking == 0) {
			char_literal83_tree = (object)adaptor.Create(char_literal83);
			adaptor.AddChild(root_0, char_literal83_tree);
			}
			DebugLocation(153, 10);
			PushFollow(Follow._type_id_in_type_field1287);
			type_id84=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, type_id84.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_field", 13);
			LeaveRule("type_field", 13);
			LeaveRule_type_field();
		}
		DebugLocation(153, 16);
		} finally { DebugExitRule(GrammarFileName, "type_field"); }
		return retval;

	}
	// $ANTLR end "type_field"

	partial void EnterRule_expr_seq();
	partial void LeaveRule_expr_seq();

	// $ANTLR start "expr_seq"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:156:1: expr_seq : expr ( ';' ! expr )* ;
	[GrammarRule("expr_seq")]
	private AstParserRuleReturnScope<object, IToken> expr_seq()
	{
		EnterRule_expr_seq();
		EnterRule("expr_seq", 14);
		TraceIn("expr_seq", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal86 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr87 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal86_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr_seq");
		DebugLocation(156, 28);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:156:9: ( expr ( ';' ! expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:156:12: expr ( ';' ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(156, 12);
			PushFollow(Follow._expr_in_expr_seq1297);
			expr85=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expr85.Tree);
			DebugLocation(156, 17);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:156:17: ( ';' ! expr )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==52))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:156:18: ';' ! expr
					{
					DebugLocation(156, 21);
					char_literal86=(IToken)Match(input,52,Follow._52_in_expr_seq1300); if (state.failed) return retval;
					DebugLocation(156, 23);
					PushFollow(Follow._expr_in_expr_seq1303);
					expr87=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr87.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_seq", 14);
			LeaveRule("expr_seq", 14);
			LeaveRule_expr_seq();
		}
		DebugLocation(156, 28);
		} finally { DebugExitRule(GrammarFileName, "expr_seq"); }
		return retval;

	}
	// $ANTLR end "expr_seq"

	partial void EnterRule_expr_list();
	partial void LeaveRule_expr_list();

	// $ANTLR start "expr_list"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:158:1: expr_list : expr ( ',' ! expr )* ;
	[GrammarRule("expr_list")]
	private AstParserRuleReturnScope<object, IToken> expr_list()
	{
		EnterRule_expr_list();
		EnterRule("expr_list", 15);
		TraceIn("expr_list", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal89 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr88 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr90 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal89_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr_list");
		DebugLocation(158, 28);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:158:10: ( expr ( ',' ! expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:158:12: expr ( ',' ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(158, 12);
			PushFollow(Follow._expr_in_expr_list1312);
			expr88=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expr88.Tree);
			DebugLocation(158, 17);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:158:17: ( ',' ! expr )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==49))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:158:18: ',' ! expr
					{
					DebugLocation(158, 21);
					char_literal89=(IToken)Match(input,49,Follow._49_in_expr_list1315); if (state.failed) return retval;
					DebugLocation(158, 23);
					PushFollow(Follow._expr_in_expr_list1318);
					expr90=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr90.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_list", 15);
			LeaveRule("expr_list", 15);
			LeaveRule_expr_list();
		}
		DebugLocation(158, 28);
		} finally { DebugExitRule(GrammarFileName, "expr_list"); }
		return retval;

	}
	// $ANTLR end "expr_list"

	partial void EnterRule_field_list();
	partial void LeaveRule_field_list();

	// $ANTLR start "field_list"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:160:1: field_list : ( ID EQUAL ! expr ) ( ',' ! ID EQUAL ! expr )* ;
	[GrammarRule("field_list")]
	private AstParserRuleReturnScope<object, IToken> field_list()
	{
		EnterRule_field_list();
		EnterRule("field_list", 16);
		TraceIn("field_list", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID91 = default(IToken);
		IToken EQUAL92 = default(IToken);
		IToken char_literal94 = default(IToken);
		IToken ID95 = default(IToken);
		IToken EQUAL96 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr93 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr97 = default(AstParserRuleReturnScope<object, IToken>);

		object ID91_tree = default(object);
		object EQUAL92_tree = default(object);
		object char_literal94_tree = default(object);
		object ID95_tree = default(object);
		object EQUAL96_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "field_list");
		DebugLocation(160, 41);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:160:11: ( ( ID EQUAL ! expr ) ( ',' ! ID EQUAL ! expr )* )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:3: ( ID EQUAL ! expr ) ( ',' ! ID EQUAL ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(161, 3);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:3: ( ID EQUAL ! expr )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:4: ID EQUAL ! expr
			{
			DebugLocation(161, 4);
			ID91=(IToken)Match(input,ID,Follow._ID_in_field_list1332); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID91_tree = (object)adaptor.Create(ID91);
			adaptor.AddChild(root_0, ID91_tree);
			}
			DebugLocation(161, 12);
			EQUAL92=(IToken)Match(input,EQUAL,Follow._EQUAL_in_field_list1334); if (state.failed) return retval;
			DebugLocation(161, 14);
			PushFollow(Follow._expr_in_field_list1337);
			expr93=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expr93.Tree);

			}

			DebugLocation(161, 20);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:20: ( ',' ! ID EQUAL ! expr )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==49))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:161:21: ',' ! ID EQUAL ! expr
					{
					DebugLocation(161, 24);
					char_literal94=(IToken)Match(input,49,Follow._49_in_field_list1341); if (state.failed) return retval;
					DebugLocation(161, 26);
					ID95=(IToken)Match(input,ID,Follow._ID_in_field_list1344); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ID95_tree = (object)adaptor.Create(ID95);
					adaptor.AddChild(root_0, ID95_tree);
					}
					DebugLocation(161, 34);
					EQUAL96=(IToken)Match(input,EQUAL,Follow._EQUAL_in_field_list1346); if (state.failed) return retval;
					DebugLocation(161, 36);
					PushFollow(Follow._expr_in_field_list1349);
					expr97=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr97.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("field_list", 16);
			LeaveRule("field_list", 16);
			LeaveRule_field_list();
		}
		DebugLocation(161, 41);
		} finally { DebugExitRule(GrammarFileName, "field_list"); }
		return retval;

	}
	// $ANTLR end "field_list"

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();

	// $ANTLR start "lvalue"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:1: lvalue : ID ( array_or_member_access )? -> ^( ID ( array_or_member_access )? ) ;
	[GrammarRule("lvalue")]
	private AstParserRuleReturnScope<object, IToken> lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 17);
		TraceIn("lvalue", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID98 = default(IToken);
		AstParserRuleReturnScope<object, IToken> array_or_member_access99 = default(AstParserRuleReturnScope<object, IToken>);

		object ID98_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_array_or_member_access=new RewriteRuleSubtreeStream(adaptor,"rule array_or_member_access");
		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(163, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:8: ( ID ( array_or_member_access )? -> ^( ID ( array_or_member_access )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:10: ID ( array_or_member_access )?
			{
			DebugLocation(163, 10);
			ID98=(IToken)Match(input,ID,Follow._ID_in_lvalue1360); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID98);

			DebugLocation(163, 13);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:13: ( array_or_member_access )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==50||LA19_0==53))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:13: array_or_member_access
				{
				DebugLocation(163, 13);
				PushFollow(Follow._array_or_member_access_in_lvalue1362);
				array_or_member_access99=array_or_member_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_array_or_member_access.Add(array_or_member_access99.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(19); }



			{
			// AST REWRITE
			// elements: array_or_member_access, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 163:37: -> ^( ID ( array_or_member_access )? )
			{
				DebugLocation(163, 40);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:40: ^( ID ( array_or_member_access )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(163, 42);
				root_1 = (object)adaptor.BecomeRoot(stream_ID.NextNode(), root_1);

				DebugLocation(163, 45);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:163:45: ( array_or_member_access )?
				if (stream_array_or_member_access.HasNext)
				{
					DebugLocation(163, 45);
					adaptor.AddChild(root_1, stream_array_or_member_access.NextTree());

				}
				stream_array_or_member_access.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lvalue", 17);
			LeaveRule("lvalue", 17);
			LeaveRule_lvalue();
		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"

	partial void EnterRule_array_or_member_access();
	partial void LeaveRule_array_or_member_access();

	// $ANTLR start "array_or_member_access"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:166:1: array_or_member_access : ( member_access | array_access ) ( array_or_member_access )? ;
	[GrammarRule("array_or_member_access")]
	private AstParserRuleReturnScope<object, IToken> array_or_member_access()
	{
		EnterRule_array_or_member_access();
		EnterRule("array_or_member_access", 18);
		TraceIn("array_or_member_access", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> member_access100 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> array_access101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> array_or_member_access102 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "array_or_member_access");
		DebugLocation(166, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:167:2: ( ( member_access | array_access ) ( array_or_member_access )? )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:167:4: ( member_access | array_access ) ( array_or_member_access )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(167, 4);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:167:4: ( member_access | array_access )
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==50))
			{
				alt20 = 1;
			}
			else if ((LA20_0==53))
			{
				alt20 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:167:5: member_access
				{
				DebugLocation(167, 5);
				PushFollow(Follow._member_access_in_array_or_member_access1385);
				member_access100=member_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, member_access100.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:167:21: array_access
				{
				DebugLocation(167, 21);
				PushFollow(Follow._array_access_in_array_or_member_access1389);
				array_access101=array_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_access101.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(167, 35);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:167:35: ( array_or_member_access )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==50||LA21_0==53))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:167:35: array_or_member_access
				{
				DebugLocation(167, 35);
				PushFollow(Follow._array_or_member_access_in_array_or_member_access1392);
				array_or_member_access102=array_or_member_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_or_member_access102.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array_or_member_access", 18);
			LeaveRule("array_or_member_access", 18);
			LeaveRule_array_or_member_access();
		}
		DebugLocation(168, 1);
		} finally { DebugExitRule(GrammarFileName, "array_or_member_access"); }
		return retval;

	}
	// $ANTLR end "array_or_member_access"

	partial void EnterRule_member_access();
	partial void LeaveRule_member_access();

	// $ANTLR start "member_access"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:170:1: member_access : '.' ID -> ^( '.' ID ) ;
	[GrammarRule("member_access")]
	private AstParserRuleReturnScope<object, IToken> member_access()
	{
		EnterRule_member_access();
		EnterRule("member_access", 19);
		TraceIn("member_access", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal103 = default(IToken);
		IToken ID104 = default(IToken);

		object char_literal103_tree = default(object);
		object ID104_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		try { DebugEnterRule(GrammarFileName, "member_access");
		DebugLocation(170, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:171:2: ( '.' ID -> ^( '.' ID ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:171:4: '.' ID
			{
			DebugLocation(171, 4);
			char_literal103=(IToken)Match(input,50,Follow._50_in_member_access1405); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_50.Add(char_literal103);

			DebugLocation(171, 8);
			ID104=(IToken)Match(input,ID,Follow._ID_in_member_access1407); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID104);



			{
			// AST REWRITE
			// elements: 50, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 171:11: -> ^( '.' ID )
			{
				DebugLocation(171, 14);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:171:14: ^( '.' ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(171, 16);
				root_1 = (object)adaptor.BecomeRoot(stream_50.NextNode(), root_1);

				DebugLocation(171, 20);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("member_access", 19);
			LeaveRule("member_access", 19);
			LeaveRule_member_access();
		}
		DebugLocation(172, 1);
		} finally { DebugExitRule(GrammarFileName, "member_access"); }
		return retval;

	}
	// $ANTLR end "member_access"

	partial void EnterRule_array_access();
	partial void LeaveRule_array_access();

	// $ANTLR start "array_access"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:174:1: array_access : '[' expr ']' -> ^( AT expr ) ;
	[GrammarRule("array_access")]
	private AstParserRuleReturnScope<object, IToken> array_access()
	{
		EnterRule_array_access();
		EnterRule("array_access", 20);
		TraceIn("array_access", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal105 = default(IToken);
		IToken char_literal107 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr106 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal105_tree = default(object);
		object char_literal107_tree = default(object);
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "array_access");
		DebugLocation(174, 1);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:175:2: ( '[' expr ']' -> ^( AT expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:175:4: '[' expr ']'
			{
			DebugLocation(175, 4);
			char_literal105=(IToken)Match(input,53,Follow._53_in_array_access1427); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_53.Add(char_literal105);

			DebugLocation(175, 8);
			PushFollow(Follow._expr_in_array_access1429);
			expr106=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr106.Tree);
			DebugLocation(175, 13);
			char_literal107=(IToken)Match(input,54,Follow._54_in_array_access1431); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_54.Add(char_literal107);



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 175:17: -> ^( AT expr )
			{
				DebugLocation(175, 20);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:175:20: ^( AT expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(175, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(AT, "AT"), root_1);

				DebugLocation(175, 25);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array_access", 20);
			LeaveRule("array_access", 20);
			LeaveRule_array_access();
		}
		DebugLocation(176, 1);
		} finally { DebugExitRule(GrammarFileName, "array_access"); }
		return retval;

	}
	// $ANTLR end "array_access"

	partial void EnterRule_declaration_list();
	partial void LeaveRule_declaration_list();

	// $ANTLR start "declaration_list"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:178:1: declaration_list : ( declaration )+ ;
	[GrammarRule("declaration_list")]
	private AstParserRuleReturnScope<object, IToken> declaration_list()
	{
		EnterRule_declaration_list();
		EnterRule("declaration_list", 21);
		TraceIn("declaration_list", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration108 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration_list");
		DebugLocation(178, 16);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:178:17: ( ( declaration )+ )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:179:3: ( declaration )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(179, 3);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:179:3: ( declaration )+
			int cnt22=0;
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==59||(LA22_0>=65 && LA22_0<=66)))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:179:4: declaration
					{
					DebugLocation(179, 4);
					PushFollow(Follow._declaration_in_declaration_list1452);
					declaration108=declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declaration108.Tree);

					}
					break;

				default:
					if (cnt22 >= 1)
						goto loop22;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee22 = new EarlyExitException( 22, input );
					DebugRecognitionException(eee22);
					throw eee22;
				}
				cnt22++;
			}
			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_list", 21);
			LeaveRule("declaration_list", 21);
			LeaveRule_declaration_list();
		}
		DebugLocation(179, 16);
		} finally { DebugExitRule(GrammarFileName, "declaration_list"); }
		return retval;

	}
	// $ANTLR end "declaration_list"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:180:1: declaration : ( type_declaration | variable_declaration | function_declaration );
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<object, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 22);
		TraceIn("declaration", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_declaration109 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variable_declaration110 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_declaration111 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(180, 23);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:180:12: ( type_declaration | variable_declaration | function_declaration )
			int alt23=3;
			try { DebugEnterDecision(23, false);
			switch (input.LA(1))
			{
			case 65:
				{
				alt23 = 1;
				}
				break;
			case 66:
				{
				alt23 = 2;
				}
				break;
			case 59:
				{
				alt23 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:181:3: type_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(181, 3);
				PushFollow(Follow._type_declaration_in_declaration1462);
				type_declaration109=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration109.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:182:4: variable_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(182, 4);
				PushFollow(Follow._variable_declaration_in_declaration1467);
				variable_declaration110=variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variable_declaration110.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:183:4: function_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(183, 4);
				PushFollow(Follow._function_declaration_in_declaration1472);
				function_declaration111=function_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_declaration111.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 22);
			LeaveRule("declaration", 22);
			LeaveRule_declaration();
		}
		DebugLocation(183, 23);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_variable_declaration();
	partial void LeaveRule_variable_declaration();

	// $ANTLR start "variable_declaration"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:185:1: variable_declaration : 'var' ID ( ':' type_id )? ASSIGN expr -> ^( VAR_DECL ID ( type_id )? expr ) ;
	[GrammarRule("variable_declaration")]
	private AstParserRuleReturnScope<object, IToken> variable_declaration()
	{
		EnterRule_variable_declaration();
		EnterRule("variable_declaration", 23);
		TraceIn("variable_declaration", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal112 = default(IToken);
		IToken ID113 = default(IToken);
		IToken char_literal114 = default(IToken);
		IToken ASSIGN116 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id115 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr117 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal112_tree = default(object);
		object ID113_tree = default(object);
		object char_literal114_tree = default(object);
		object ASSIGN116_tree = default(object);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_51=new RewriteRuleITokenStream(adaptor,"token 51");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "variable_declaration");
		DebugLocation(185, 69);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:185:21: ( 'var' ID ( ':' type_id )? ASSIGN expr -> ^( VAR_DECL ID ( type_id )? expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:186:3: 'var' ID ( ':' type_id )? ASSIGN expr
			{
			DebugLocation(186, 3);
			string_literal112=(IToken)Match(input,66,Follow._66_in_variable_declaration1482); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_66.Add(string_literal112);

			DebugLocation(186, 9);
			ID113=(IToken)Match(input,ID,Follow._ID_in_variable_declaration1484); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID113);

			DebugLocation(186, 12);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:186:12: ( ':' type_id )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==51))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:186:13: ':' type_id
				{
				DebugLocation(186, 13);
				char_literal114=(IToken)Match(input,51,Follow._51_in_variable_declaration1487); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_51.Add(char_literal114);

				DebugLocation(186, 17);
				PushFollow(Follow._type_id_in_variable_declaration1489);
				type_id115=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id115.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(186, 27);
			ASSIGN116=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variable_declaration1493); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN116);

			DebugLocation(186, 34);
			PushFollow(Follow._expr_in_variable_declaration1495);
			expr117=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr117.Tree);


			{
			// AST REWRITE
			// elements: expr, ID, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 186:39: -> ^( VAR_DECL ID ( type_id )? expr )
			{
				DebugLocation(186, 42);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:186:42: ^( VAR_DECL ID ( type_id )? expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(186, 44);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR_DECL, "VAR_DECL"), root_1);

				DebugLocation(186, 53);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(186, 56);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:186:56: ( type_id )?
				if (stream_type_id.HasNext)
				{
					DebugLocation(186, 56);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

				}
				stream_type_id.Reset();
				DebugLocation(186, 65);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable_declaration", 23);
			LeaveRule("variable_declaration", 23);
			LeaveRule_variable_declaration();
		}
		DebugLocation(186, 69);
		} finally { DebugExitRule(GrammarFileName, "variable_declaration"); }
		return retval;

	}
	// $ANTLR end "variable_declaration"

	partial void EnterRule_function_declaration();
	partial void LeaveRule_function_declaration();

	// $ANTLR start "function_declaration"
	// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:188:1: function_declaration : 'function' ID '(' ( type_fields )? ')' ( ':' type_id )? EQUAL expr -> ^( FUNCTION_DECL ID ( type_fields )? ( type_id )? expr ) ;
	[GrammarRule("function_declaration")]
	private AstParserRuleReturnScope<object, IToken> function_declaration()
	{
		EnterRule_function_declaration();
		EnterRule("function_declaration", 24);
		TraceIn("function_declaration", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal118 = default(IToken);
		IToken ID119 = default(IToken);
		IToken char_literal120 = default(IToken);
		IToken char_literal122 = default(IToken);
		IToken char_literal123 = default(IToken);
		IToken EQUAL125 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_fields121 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id124 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr126 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal118_tree = default(object);
		object ID119_tree = default(object);
		object char_literal120_tree = default(object);
		object char_literal122_tree = default(object);
		object char_literal123_tree = default(object);
		object EQUAL125_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_51=new RewriteRuleITokenStream(adaptor,"token 51");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "function_declaration");
		DebugLocation(188, 112);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:188:21: ( 'function' ID '(' ( type_fields )? ')' ( ':' type_id )? EQUAL expr -> ^( FUNCTION_DECL ID ( type_fields )? ( type_id )? expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:3: 'function' ID '(' ( type_fields )? ')' ( ':' type_id )? EQUAL expr
			{
			DebugLocation(189, 3);
			string_literal118=(IToken)Match(input,59,Follow._59_in_function_declaration1517); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_59.Add(string_literal118);

			DebugLocation(189, 14);
			ID119=(IToken)Match(input,ID,Follow._ID_in_function_declaration1519); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID119);

			DebugLocation(189, 17);
			char_literal120=(IToken)Match(input,47,Follow._47_in_function_declaration1521); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_47.Add(char_literal120);

			DebugLocation(189, 21);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:21: ( type_fields )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_0 = input.LA(1);

			if ((LA25_0==ID))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:21: type_fields
				{
				DebugLocation(189, 21);
				PushFollow(Follow._type_fields_in_function_declaration1523);
				type_fields121=type_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_fields.Add(type_fields121.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(189, 34);
			char_literal122=(IToken)Match(input,48,Follow._48_in_function_declaration1526); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal122);

			DebugLocation(189, 38);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:38: ( ':' type_id )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==51))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:39: ':' type_id
				{
				DebugLocation(189, 39);
				char_literal123=(IToken)Match(input,51,Follow._51_in_function_declaration1529); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_51.Add(char_literal123);

				DebugLocation(189, 43);
				PushFollow(Follow._type_id_in_function_declaration1531);
				type_id124=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id124.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(189, 53);
			EQUAL125=(IToken)Match(input,EQUAL,Follow._EQUAL_in_function_declaration1535); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQUAL.Add(EQUAL125);

			DebugLocation(189, 59);
			PushFollow(Follow._expr_in_function_declaration1537);
			expr126=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr126.Tree);


			{
			// AST REWRITE
			// elements: type_fields, expr, ID, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 189:64: -> ^( FUNCTION_DECL ID ( type_fields )? ( type_id )? expr )
			{
				DebugLocation(189, 67);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:67: ^( FUNCTION_DECL ID ( type_fields )? ( type_id )? expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(189, 69);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_DECL, "FUNCTION_DECL"), root_1);

				DebugLocation(189, 83);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(189, 86);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:86: ( type_fields )?
				if (stream_type_fields.HasNext)
				{
					DebugLocation(189, 86);
					adaptor.AddChild(root_1, stream_type_fields.NextTree());

				}
				stream_type_fields.Reset();
				DebugLocation(189, 99);
				// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:189:99: ( type_id )?
				if (stream_type_id.HasNext)
				{
					DebugLocation(189, 99);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

				}
				stream_type_id.Reset();
				DebugLocation(189, 108);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function_declaration", 24);
			LeaveRule("function_declaration", 24);
			LeaveRule_function_declaration();
		}
		DebugLocation(189, 112);
		} finally { DebugExitRule(GrammarFileName, "function_declaration"); }
		return retval;

	}
	// $ANTLR end "function_declaration"

	partial void EnterRule_synpred1_Tiger_fragment();
	partial void LeaveRule_synpred1_Tiger_fragment();

	// $ANTLR start synpred1_Tiger
	public void synpred1_Tiger_fragment()
	{
		EnterRule_synpred1_Tiger_fragment();
		EnterRule("synpred1_Tiger_fragment", 25);
		TraceIn("synpred1_Tiger_fragment", 25);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:123:5: ( ID '[' expr ']' 'of' )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:123:6: ID '[' expr ']' 'of'
			{
			DebugLocation(123, 6);
			Match(input,ID,Follow._ID_in_synpred1_Tiger790); if (state.failed) return;
			DebugLocation(123, 9);
			Match(input,53,Follow._53_in_synpred1_Tiger792); if (state.failed) return;
			DebugLocation(123, 13);
			PushFollow(Follow._expr_in_synpred1_Tiger794);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(123, 18);
			Match(input,54,Follow._54_in_synpred1_Tiger796); if (state.failed) return;
			DebugLocation(123, 22);
			Match(input,62,Follow._62_in_synpred1_Tiger798); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Tiger_fragment", 25);
			LeaveRule("synpred1_Tiger_fragment", 25);
			LeaveRule_synpred1_Tiger_fragment();
		}
	}
	// $ANTLR end synpred1_Tiger

	partial void EnterRule_synpred2_Tiger_fragment();
	partial void LeaveRule_synpred2_Tiger_fragment();

	// $ANTLR start synpred2_Tiger
	public void synpred2_Tiger_fragment()
	{
		EnterRule_synpred2_Tiger_fragment();
		EnterRule("synpred2_Tiger_fragment", 26);
		TraceIn("synpred2_Tiger_fragment", 26);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:5: ( ID '(' )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:124:6: ID '('
			{
			DebugLocation(124, 6);
			Match(input,ID,Follow._ID_in_synpred2_Tiger839); if (state.failed) return;
			DebugLocation(124, 9);
			Match(input,47,Follow._47_in_synpred2_Tiger841); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_Tiger_fragment", 26);
			LeaveRule("synpred2_Tiger_fragment", 26);
			LeaveRule_synpred2_Tiger_fragment();
		}
	}
	// $ANTLR end synpred2_Tiger

	partial void EnterRule_synpred3_Tiger_fragment();
	partial void LeaveRule_synpred3_Tiger_fragment();

	// $ANTLR start synpred3_Tiger
	public void synpred3_Tiger_fragment()
	{
		EnterRule_synpred3_Tiger_fragment();
		EnterRule("synpred3_Tiger_fragment", 27);
		TraceIn("synpred3_Tiger_fragment", 27);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:5: ( ID '{' )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:125:6: ID '{'
			{
			DebugLocation(125, 6);
			Match(input,ID,Follow._ID_in_synpred3_Tiger875); if (state.failed) return;
			DebugLocation(125, 9);
			Match(input,67,Follow._67_in_synpred3_Tiger877); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_Tiger_fragment", 27);
			LeaveRule("synpred3_Tiger_fragment", 27);
			LeaveRule_synpred3_Tiger_fragment();
		}
	}
	// $ANTLR end synpred3_Tiger

	partial void EnterRule_synpred4_Tiger_fragment();
	partial void LeaveRule_synpred4_Tiger_fragment();

	// $ANTLR start synpred4_Tiger
	public void synpred4_Tiger_fragment()
	{
		EnterRule_synpred4_Tiger_fragment();
		EnterRule("synpred4_Tiger_fragment", 28);
		TraceIn("synpred4_Tiger_fragment", 28);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:5: ( lvalue ASSIGN )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:126:6: lvalue ASSIGN
			{
			DebugLocation(126, 6);
			PushFollow(Follow._lvalue_in_synpred4_Tiger909);
			lvalue();
			PopFollow();
			if (state.failed) return;
			DebugLocation(126, 13);
			Match(input,ASSIGN,Follow._ASSIGN_in_synpred4_Tiger911); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_Tiger_fragment", 28);
			LeaveRule("synpred4_Tiger_fragment", 28);
			LeaveRule_synpred4_Tiger_fragment();
		}
	}
	// $ANTLR end synpred4_Tiger

	partial void EnterRule_synpred5_Tiger_fragment();
	partial void LeaveRule_synpred5_Tiger_fragment();

	// $ANTLR start synpred5_Tiger
	public void synpred5_Tiger_fragment()
	{
		EnterRule_synpred5_Tiger_fragment();
		EnterRule("synpred5_Tiger_fragment", 29);
		TraceIn("synpred5_Tiger_fragment", 29);
		try
		{
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:5: ( 'if' expr 'then' expr 'else' )
			DebugEnterAlt(1);
			// C:\\Users\\Frank\\Desktop\\Compilación\\TigerCompiler\\Tiger.g:129:6: 'if' expr 'then' expr 'else'
			{
			DebugLocation(129, 6);
			Match(input,60,Follow._60_in_synpred5_Tiger965); if (state.failed) return;
			DebugLocation(129, 11);
			PushFollow(Follow._expr_in_synpred5_Tiger967);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(129, 16);
			Match(input,63,Follow._63_in_synpred5_Tiger969); if (state.failed) return;
			DebugLocation(129, 23);
			PushFollow(Follow._expr_in_synpred5_Tiger971);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(129, 28);
			Match(input,57,Follow._57_in_synpred5_Tiger973); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_Tiger_fragment", 29);
			LeaveRule("synpred5_Tiger_fragment", 29);
			LeaveRule_synpred5_Tiger_fragment();
		}
	}
	// $ANTLR end synpred5_Tiger
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expr_in_program616 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program618 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _or_expr_in_expr634 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _and_exp_in_or_expr642 = new BitSet(new ulong[]{0x400000002UL});
		public static readonly BitSet _OR_in_or_expr645 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _and_exp_in_or_expr648 = new BitSet(new ulong[]{0x400000002UL});
		public static readonly BitSet _comp_expr_in_and_exp660 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _AND_in_and_exp663 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _comp_expr_in_and_exp666 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _arith_expr_in_comp_expr679 = new BitSet(new ulong[]{0x230604002UL});
		public static readonly BitSet _EQUAL_in_comp_expr682 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _NON_EQUAL_in_comp_expr687 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _LT_in_comp_expr692 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _GT_in_comp_expr697 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _LT_EQUAL_in_comp_expr702 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _GT_EQUAL_in_comp_expr707 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _arith_expr_in_comp_expr711 = new BitSet(new ulong[]{0x230604002UL});
		public static readonly BitSet _term_in_arith_expr724 = new BitSet(new ulong[]{0x840000002UL});
		public static readonly BitSet _PLUS_in_arith_expr727 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _MINUS_in_arith_expr730 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _term_in_arith_expr734 = new BitSet(new ulong[]{0x840000002UL});
		public static readonly BitSet _texpr_in_term746 = new BitSet(new ulong[]{0x80002002UL});
		public static readonly BitSet _MUL_in_term749 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _DIV_in_term752 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _texpr_in_term756 = new BitSet(new ulong[]{0x80002002UL});
		public static readonly BitSet _STRING_in_texpr771 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_texpr777 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NIL_in_texpr783 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_texpr803 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_texpr805 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr809 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_texpr811 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_texpr813 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr817 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_texpr845 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_texpr847 = new BitSet(new ulong[]{0x1001A1014C840800UL});
		public static readonly BitSet _expr_list_in_texpr849 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_texpr852 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_texpr883 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _67_in_texpr885 = new BitSet(new ulong[]{0x800000UL,0x10UL});
		public static readonly BitSet _field_list_in_texpr887 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _68_in_texpr890 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_texpr917 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_texpr919 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr921 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_texpr938 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _47_in_texpr944 = new BitSet(new ulong[]{0x1001A1014C840800UL});
		public static readonly BitSet _expr_seq_in_texpr946 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_texpr949 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _60_in_texpr979 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr983 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_texpr985 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr989 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_texpr991 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr995 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _60_in_texpr1017 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr1021 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_texpr1023 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr1027 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_texpr1045 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr1049 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_texpr1051 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr1055 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_texpr1073 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _ID_in_texpr1077 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_texpr1079 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr1083 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_texpr1085 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr1089 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_texpr1091 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_texpr1095 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_texpr1119 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_texpr1125 = new BitSet(new ulong[]{0x800000000000000UL,0x6UL});
		public static readonly BitSet _declaration_list_in_texpr1127 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _61_in_texpr1129 = new BitSet(new ulong[]{0x1400A1014C840800UL});
		public static readonly BitSet _expr_seq_in_texpr1131 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_texpr1134 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_texpr1151 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _texpr_in_texpr1153 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_type_id1174 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _65_in_type_declaration1194 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _type_id_in_type_declaration1196 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_type_declaration1198 = new BitSet(new ulong[]{0x80000000800000UL,0x8UL});
		public static readonly BitSet _type_in_type_declaration1200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_type1218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _67_in_type1227 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _type_fields_in_type1229 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _68_in_type1231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _55_in_type1244 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_type1246 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _type_id_in_type1248 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_field_in_type_fields1266 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _49_in_type_fields1269 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _type_field_in_type_fields1271 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _ID_in_type_field1283 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_type_field1285 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _type_id_in_type_field1287 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_expr_seq1297 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _52_in_expr_seq1300 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_expr_seq1303 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _expr_in_expr_list1312 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _49_in_expr_list1315 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_expr_list1318 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _ID_in_field_list1332 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_field_list1334 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_field_list1337 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _49_in_field_list1341 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _ID_in_field_list1344 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_field_list1346 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_field_list1349 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _ID_in_lvalue1360 = new BitSet(new ulong[]{0x24000000000002UL});
		public static readonly BitSet _array_or_member_access_in_lvalue1362 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _member_access_in_array_or_member_access1385 = new BitSet(new ulong[]{0x24000000000002UL});
		public static readonly BitSet _array_access_in_array_or_member_access1389 = new BitSet(new ulong[]{0x24000000000002UL});
		public static readonly BitSet _array_or_member_access_in_array_or_member_access1392 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _50_in_member_access1405 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _ID_in_member_access1407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _53_in_array_access1427 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_array_access1429 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_array_access1431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_declaration_list1452 = new BitSet(new ulong[]{0x800000000000002UL,0x6UL});
		public static readonly BitSet _type_declaration_in_declaration1462 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_declaration1467 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_declaration_in_declaration1472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_variable_declaration1482 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _ID_in_variable_declaration1484 = new BitSet(new ulong[]{0x8000000000200UL});
		public static readonly BitSet _51_in_variable_declaration1487 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _type_id_in_variable_declaration1489 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_variable_declaration1493 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_variable_declaration1495 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _59_in_function_declaration1517 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _ID_in_function_declaration1519 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_function_declaration1521 = new BitSet(new ulong[]{0x1000000800000UL});
		public static readonly BitSet _type_fields_in_function_declaration1523 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_function_declaration1526 = new BitSet(new ulong[]{0x8000000004000UL});
		public static readonly BitSet _51_in_function_declaration1529 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _type_id_in_function_declaration1531 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_function_declaration1535 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_function_declaration1537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred1_Tiger790 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_synpred1_Tiger792 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_synpred1_Tiger794 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_synpred1_Tiger796 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_synpred1_Tiger798 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred2_Tiger839 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_synpred2_Tiger841 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred3_Tiger875 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _67_in_synpred3_Tiger877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_synpred4_Tiger909 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_synpred4_Tiger911 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _60_in_synpred5_Tiger965 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_synpred5_Tiger967 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_synpred5_Tiger969 = new BitSet(new ulong[]{0x1000A1014C840800UL});
		public static readonly BitSet _expr_in_synpred5_Tiger971 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_synpred5_Tiger973 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
